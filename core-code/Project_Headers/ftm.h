/**
 * @file     ftm.h (180.ARM_Peripherals/Project_Headers/ftm.h)
 * @brief    Flexitimer Timer Module
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef HEADER_FTM_H
#define HEADER_FTM_H
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stddef.h>
#include <assert.h>
#include "derivative.h"
#include <cmath>

/*
 * Default port information
 */

#ifndef FTM0_CLOCK_MASK
#ifdef SIM_SCGC6_FTM0_MASK
#define FTM0_CLOCK_MASK SIM_SCGC6_FTM0_MASK
#define FTM0_CLOCK_REG  SCGC6
#endif
#ifdef SIM_SCGC6_FTM1_MASK
#define FTM1_CLOCK_MASK SIM_SCGC6_FTM1_MASK
#define FTM1_CLOCK_REG  SCGC6
#endif
#ifdef SIM_SCGC6_FTM2_MASK
#define FTM2_CLOCK_MASK SIM_SCGC6_FTM2_MASK
#define FTM2_CLOCK_REG  SCGC6
#elif defined SIM_SCGC3_FTM2_MASK
#define FTM2_CLOCK_MASK SIM_SCGC3_FTM2_MASK
#define FTM2_CLOCK_REG  SCGC3
#endif
#ifdef SIM_SCGC6_FTM3_MASK
#define FTM3_CLOCK_MASK SIM_SCGC6_FTM3_MASK
#define FTM3_CLOCK_REG  SCGC6
#endif
#ifdef SIM_SCGC3_FTM3_MASK
#define FTM3_CLOCK_MASK SIM_SCGC3_FTM3_MASK
#define FTM3_CLOCK_REG  SCGC3
#endif
#ifdef SIM_SCGC3_FTM3_MASKC
#define FTM3_CLOCK_MASK SIM_SCGC3_FTM3_MASKC
#define FTM3_CLOCK_REG  SCGC3
#endif
#endif

namespace USBDM {

/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Pins used for PWM, Input capture and Output compare
 * @{
 */

/**
 *  Control mode of operation of shared FTM counter
 */
enum FtmMode {
   //! Up counter: Used for left-aligned PWM, input capture and output compare modes
   FtmMode_LeftAlign   = FTM_SC_CPWMS(0),
   //! Up-down counter: Used for centre-aligned PWM 
   FtmMode_CentreAlign = FTM_SC_CPWMS(1),
   //! Dummy value: Used for quadrature encoder
   FtmMode_Quadrature  = 0,               
};

/**
 * Controls basic operation of PWM/Input capture
 */
enum FtmChMode {
   FtmChMode_InputCaptureRisingEdge                = FTM_CnSC_MS(0)|FTM_CnSC_ELS(1), //!< Capture rising edge
   FtmChMode_InputCaptureFallingEdge               = FTM_CnSC_MS(0)|FTM_CnSC_ELS(2), //!< Capture falling edge
   FtmChMode_InputCaptureEitherEdge                = FTM_CnSC_MS(0)|FTM_CnSC_ELS(3), //!< Capture both rising and falling edges
   FtmChMode_OutputCompare                         = FTM_CnSC_MS(1),                 //!< Output compare operation without pin action
   FtmChMode_OutputCompareToggle                   = FTM_CnSC_MS(1)|FTM_CnSC_ELS(1), //!< Toggle pin on output compare
   FtmChMode_OutputCompareClear                    = FTM_CnSC_MS(1)|FTM_CnSC_ELS(2), //!< Clear pin on output compare
   FtmChMode_OutputCompareSet                      = FTM_CnSC_MS(1)|FTM_CnSC_ELS(3), //!< Set pin on output compare
   FtmChMode_PwmHighTruePulses                     = FTM_CnSC_MS(2)|FTM_CnSC_ELS(2), //!< PWM with high-true pulses
   FtmChMode_PwmLowTruePulses                      = FTM_CnSC_MS(2)|FTM_CnSC_ELS(1), //!< PWM with low-true pulses
   FtmChMode_DualEdgeCaptureOneShotRisingEdge      = FTM_CnSC_MS(0)|FTM_CnSC_ELS(1), //!< Dual edge input capture one shot - CHn configuration
   FtmChMode_DualEdgeCaptureContinuousRisingEdge   = FTM_CnSC_MS(1)|FTM_CnSC_ELS(1), //!< Dual edge input capture continuous - CHn configuration
   FtmChMode_DualEdgeCaptureOneShotFallingEdge     = FTM_CnSC_MS(0)|FTM_CnSC_ELS(2), //!< Dual edge input capture one shot - CHn configuration
   FtmChMode_DualEdgeCaptureContinuousFallingEdge  = FTM_CnSC_MS(1)|FTM_CnSC_ELS(2), //!< Dual edge input capture continuous - CHn configuration
   FtmChMode_CombinePositivePulse                  = FTM_CnSC_MS(0)|FTM_CnSC_ELS(2), //!< Combine mode - CHn configuration
   FtmChMode_CombineNegativePulse                  = FTM_CnSC_MS(0)|FTM_CnSC_ELS(1), //!< Combine mode - CHn configuration
};

/**
 * Control alignment of PWM function
 */
enum FtmClockSource {
   FtmClockSource_None        = FTM_SC_CLKS(0),  //!< Timer is disabled
   FtmClockSource_System      = FTM_SC_CLKS(1),  //!< System clock (usually the bus clock)
   FtmClockSource_FixedFreq   = FTM_SC_CLKS(2),  //!< Fixed frequency clock (various sources such as FLL,PLL)
   FtmClockSource_External    = FTM_SC_CLKS(3),  //!< External clock provided to FTM_CLKINx pin
};

/**
 * Control Prescaler for FTM clock
 */
enum FtmPrescale {
   FtmPrescale_1   = FTM_SC_PS(0),  //!< Divide by 1
   FtmPrescale_2   = FTM_SC_PS(1),  //!< Divide by 2
   FtmPrescale_4   = FTM_SC_PS(2),  //!< Divide by 4
   FtmPrescale_8   = FTM_SC_PS(3),  //!< Divide by 8
   FtmPrescale_16  = FTM_SC_PS(4),  //!< Divide by 16
   FtmPrescale_32  = FTM_SC_PS(5),  //!< Divide by 32
   FtmPrescale_64  = FTM_SC_PS(6),  //!< Divide by 64
   FtmPrescale_128 = FTM_SC_PS(7),  //!< Divide by 128
};

/**
 * Enables External trigger on a channel comparison or initialisation event
 */
enum FtmExternalTrigger {
   FtmExternalTrigger_ch0   = FTM_EXTTRIG_CH0TRIG_MASK,    //!< External trigger on channel 0 event
   FtmExternalTrigger_ch1   = FTM_EXTTRIG_CH1TRIG_MASK,    //!< External trigger on channel 1 event
   FtmExternalTrigger_ch2   = FTM_EXTTRIG_CH2TRIG_MASK,    //!< External trigger on channel 2 event
   FtmExternalTrigger_ch3   = FTM_EXTTRIG_CH3TRIG_MASK,    //!< External trigger on channel 3 event
   FtmExternalTrigger_ch4   = FTM_EXTTRIG_CH4TRIG_MASK,    //!< External trigger on channel 4 event
   FtmExternalTrigger_ch5   = FTM_EXTTRIG_CH5TRIG_MASK,    //!< External trigger on channel 5 event
   FtmExternalTrigger_init  = FTM_EXTTRIG_INITTRIGEN_MASK, //!< External trigger on initialisation
   FtmExternalTrigger_all   = 0x7F,                        //!< All triggers
};

/*
 * Enabled Timer interrupt
 */
enum FtmChannelIrq {
   FtmChannelIrq_Disable = FTM_CnSC_CHIE(0), //!< Disable interrupts from this channel
   FtmChannelIrq_Enable  = FTM_CnSC_CHIE(1), //!< Enable interrupts from this channel
};

/*
 * Enabled Timer DMA
 */
enum FtmChannelDma {
   FtmChannelDma_Disable = FTM_CnSC_DMA(0), //!< Disable DMA requests from this channel
   FtmChannelDma_Enable  = FTM_CnSC_DMA(1), //!< Enable DMA requests from this channel
};

/**
 * Type definition for FTM timer overflow interrupt call back
 */
typedef void (*FtmCallbackFunction)();
/**
 * Type definition for FTM channel interrupt call back
 *
 * @param[in] status Flags indicating interrupt source channel(s)
 */
typedef void (*FtmChannelCallbackFunction)(uint8_t status);

/**
 * Base class representing an FTM
 *
 * Example
 * @code
 * // Using FTM0
 * using Ftm0 = USBDM::FtmBase_T<FTM0_Info)>;
 *
 * // Initialise PWM with initial alignment and default clock source
 * Ftm0::configure(FtmMode_LeftAlign);
 *
 * // Set timer period
 * Ftm0::setPeriod(500);
 * @endcode
 *
 * @tparam Info  Class describing FTM hardware instance
 */
template<class Info>
class FtmBase_T {

private:
   /**
    * This class is not intended to be instantiated
    */
   FtmBase_T() = delete;
   FtmBase_T(const FtmBase_T&) = delete;
   FtmBase_T(FtmBase_T&&) = delete;

protected:
   /** Callback to catch unhandled interrupt */
   static void unhandledCallback(uint8_t) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }
   /** Callback to catch unhandled interrupt */
   static void unhandledCallback() {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

public:
   /** Hardware instance pointer */
   static constexpr volatile FTM_Type* tmr      = Info::ftm;

   /** Clock register mask for peripheral */
   static constexpr volatile uint32_t *clockReg = Info::clockReg;

   /**
    * Enables clock to peripheral and configures all pins
    */
   static void __attribute__((always_inline)) enable() {
      // Configure pins
      Info::initPCRs();

      // Enable clock to peripheral
      *clockReg |= Info::clockMask;
      __DMB();
   }
   
   /**
    * Configure with settings from Configure.usbdmProject.\n
    * Includes configuring all pins
    */
   static void defaultConfigure() {
      enable();

      // Common registers
      tmr->CNTIN   = 0;
      tmr->MOD     = Info::mod;
      tmr->SC      = Info::sc;
      tmr->EXTTRIG = Info::exttrig;
      //TODO Make configurable
      tmr->CONF    = FTM_CONF_BDMMODE(1);
      //TODO Make configurable
      tmr->COMBINE = FTM_COMBINE_FAULTEN0_MASK|FTM_COMBINE_FAULTEN1_MASK|FTM_COMBINE_FAULTEN2_MASK|FTM_COMBINE_FAULTEN3_MASK;

      enableNvicInterrupts();
   }

   /**
    * Enables clock to peripheral and configures all pins
    * Configures main operating settings for timer
    *
    * @param[in] ftmMode        Mode of operation
    * @param[in] ftmClockSource Clock source for timer
    * @param[in] ftmPrescale    Clock prescaler. Used to divide clock source before use
    */
   static void configure(
         FtmMode        ftmMode,
         FtmClockSource ftmClockSource = FtmClockSource_System,
         FtmPrescale    ftmPrescale    = FtmPrescale_128) {

      enable();
      tmr->SC = ftmMode|ftmClockSource|ftmPrescale;
   }

   /**
    * Check if FTM is enabled\n
    * Just check for clock enable and clock source selection
    *
    * @return True => enabled
    */
   static __attribute__((always_inline)) bool isEnabled() {
      return ((*clockReg & Info::clockMask) != 0) && ((tmr->SC & FTM_SC_CLKS_MASK) != 0);
   }

   /**
    * Set timer mode
    *
    * @param[in] ftmMode        Mode of operation
    */
   static void setMode(FtmMode ftmMode=FtmMode_LeftAlign) {
      tmr->SC = (tmr->SC&~FTM_SC_CPWMS_MASK)|ftmMode;
   }

   /**
    * Set timer clock source
    *
    * @param[in] ftmClockSource Clock source for timer
    */
   static void setClockSource(FtmClockSource ftmClockSource=FtmClockSource_System) {
      tmr->SC = (tmr->SC&~FTM_SC_CLKS_MASK)|ftmClockSource;
   }

   /**
    *  Set timer prescaler
    *
    * @param[in] ftmPrescale    Clock prescaler. Used to divide clock source before use
    */
   static void setPrescaler(FtmPrescale ftmPrescale=FtmPrescale_128) {
      tmr->SC = (tmr->SC&~FTM_SC_PS_MASK)|ftmPrescale;
   }

   /**
    * Enable/disable Timer interrupts in NVIC
    *
    * @param[in] enable true to enable, false to disable
    */
   static __attribute__((always_inline)) void enableNvicInterrupts(bool enable=true) {

      if (enable) {
         // Enable interrupts
         NVIC_EnableIRQ(Info::irqNums[0]);

         // Set priority level
         NVIC_SetPriority(Info::irqNums[0], Info::irqLevel);
      }
      else {
         // Disable interrupts
         NVIC_DisableIRQ(Info::irqNums[0]);
      }
   }

   /**
    * Enable/disable Timer Overflow interrupts
    *
    * @param[in] enable true to enable, false to disable
    */
   static __attribute__((always_inline)) void enableTimerOverflowInterrupts(bool enable=true) {
      if (enable) {
         tmr->SC |= FTM_SC_TOIE_MASK;
      }
      else {
         tmr->SC &= ~FTM_SC_TOIE_MASK;
      }
   }

   /**
    * Set modulo of counter
    *
    * @param[in] modulo Modulo value in ticks (<65535)
    */
   void __attribute__((always_inline)) setMod(uint16_t modulo) {
      tmr->MOD = modulo;
   }

   /**
    * Set starting count of counter
    *
    * @param[in] countIn Starting count in ticks (<65535)
    */
   void __attribute__((always_inline)) setCountIn(uint16_t countIn) {
      tmr->CNTIN = countIn;
   }

   /**
    * Set period
    *
    * @param[in] period Period in ticks (<65535)
    *
    * @return E_NO_ERROR       Success
    * @return E_TOO_LARGE      Failed to find suitable pre-scaler values
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   static ErrorCode setPeriodInTicks(uint32_t period) {

      // Check if CPWMS is set (affects period)
      bool centreAlign = (tmr->SC&FTM_SC_CPWMS_MASK);

      if (centreAlign) {
         // Centre-aligned period is 2*MOD value but MOD is
         // limited to 0x7FFF for sensible PWM operation

         // Halve with rounding
         period = (period+1)/2;
#ifdef DEBUG_BUILD
         if (period > 0x7FFFUL) {
            // Attempt to set too long a period
            return setErrorCode(E_TOO_LARGE);
         }
#endif
      }
      else {
         // Left-aligned period is MOD+1 value
         period = period-1;
#ifdef DEBUG_BUILD
         if (period > 0xFFFF) {
            // Attempt to set too long a period
            return setErrorCode(E_TOO_LARGE);
         }
#endif
      }

      // Disable timer so register changes are immediate
      uint8_t sc = tmr->SC;
      tmr->SC = FTM_SC_CLKS(0);

      // Change modulo
      tmr->MOD = period;

      // Restar timer
      tmr->SC  = sc;

      // OK period
      return setErrorCode(E_NO_ERROR);
   }

   /**
    * Set period
    *
    * @param[in] period Period in seconds as a float
    *
    * @note Adjusts Timer pre-scaler to appropriate value.
    *       This will affect all channels of the timer.
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL => failed to find suitable values
    * @return E_TOO_LARGE => failed to find suitable values
    */
   static ErrorCode setPeriod(float period) {
      float inputClock = Info::getInputClockFrequency();
      int prescaleFactor=1;
      int prescalerValue=0;

      // Maximum period value in ticks
      uint32_t maxPeriodInTicks = 65536;

      // Check if CPWMS is set (affects period calculation)
      if (tmr->SC&FTM_SC_CPWMS_MASK) {
         // Centre-aligned period is ~double the MOD value but MOD is
         // limited to 0x7FFF for sensible PWM operation so
         // period in ticks is limited to 2*0x7FFF
         maxPeriodInTicks = 65534;
      }
      while (prescalerValue<=7) {
         float    clock = inputClock/prescaleFactor;
         uint32_t periodInTicks   = round(period*clock);
         if (periodInTicks < Info::minimumResolution) {
            // Too short a period for 1% resolution
            return setErrorCode(E_TOO_SMALL);
         }
         if (periodInTicks <= maxPeriodInTicks) {
            tmr->SC     = (tmr->SC&~FTM_SC_PS_MASK)|FTM_SC_PS(prescalerValue);
            setPeriodInTicks(periodInTicks);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setErrorCode(E_TOO_LARGE);
   }

   /**
    * Set measurement period.
    * Input Capture and Output Compare will be able to operate over
    *  at least this period without overflow.
    *
    * @param[in] period Period in seconds as a float
    *
    * @note Adjusts Timer pre-scaler to appropriate value.
    *       Timer period is set to maximum.
    *       This will affect all channels of the timer.
    *
    * @return E_NO_ERROR  => success
    * @return E_TOO_SMALL => failed to find suitable values
    * @return E_TOO_LARGE => failed to find suitable values
    */
   static __attribute__((always_inline)) ErrorCode setMeasurementPeriod(float period) {
      // Try to set capture period
      ErrorCode rc = setPeriod(period);
      // Set actual period to maximum ticks in any case
      // This is the usual value for IC or OC set-up
      setPeriodInTicks(0x10000);
      return rc;
   }
   /**
    * Get frequency of timer tick
    *
    * @return Timer frequency in Hz
    */
   static __attribute__((always_inline)) float getTickFrequency() {

      // Calculate timer prescale factor
      int prescaleFactor = 1<<((tmr->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT);

      return (float)Info::getInputClockFrequency() / prescaleFactor;
   }

   /**
    * Set approximate frequency of timer tick
    *
    * @param[in] frequency Frequency as a float
    * @param[in] tolerance Tolerance in percent
    *
    * @note Adjusts Timer pre-scaler to appropriate value.
    *       This will affect all channels
    *
    * @return E_NO_ERROR       Success
    * @return E_ILLEGAL_PARAM  Failed to find suitable pre-scaler values
    */
   static ErrorCode setTickFrequency(float frequency, float tolerance) {
      float inputClockFrequency = Info::getInputClockFrequency();

      int prescaleFactor=1;
      int prescalerValue=0;
      while (prescalerValue<=7) {
         float tickFrequency = inputClockFrequency/prescaleFactor;

         if ((100*std::abs((tickFrequency/frequency)-1)) < tolerance) {
            // Clear SC so immediate effect on prescale change
            uint32_t sc = tmr->SC&~FTM_SC_PS_MASK;
            tmr->SC     = 0;
            __DSB();
            tmr->SC     = sc|FTM_SC_PS(prescalerValue);
            return E_NO_ERROR;
         }
         prescalerValue++;
         prescaleFactor <<= 1;
      }
      // Too long a period
      return setErrorCode(E_ILLEGAL_PARAM);
   }

   /**
    * Converts a time in microseconds to number of ticks
    *
    * @param[in] time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   static uint32_t convertMicrosecondsToTicks(int time) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = ((uint64_t)time*tickRate)/1000000;
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts a time in microseconds to number of ticks
    *
    * @param[in] time Time in microseconds
    *
    * @return Time in ticks
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   static uint32_t convertSecondsToTicks(float time) {

      // Calculate period
      float    tickRate = Info::getClockFrequencyF();
      uint64_t rv       = time*tickRate;
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts ticks to time in microseconds
    *
    * @param[in] tickInterval Time in ticks
    *
    * @return Time in microseconds
    *
    * @note Assumes prescale has been chosen as a appropriate value. Rudimentary range checking.
    */
   static uint32_t convertTicksToMicroseconds(int tickInterval) {

      // Calculate period
      uint32_t tickRate = Info::getClockFrequency();
      uint64_t rv       = ((uint64_t)tickInterval*1000000)/tickRate;
#ifdef DEBUG_BUILD
      if (rv > 0xFFFFUL) {
         // Attempt to set too long a period
         setErrorCode(E_TOO_LARGE);
      }
      if (rv == 0) {
         // Attempt to set too short a period
         setErrorCode(E_TOO_SMALL);
      }
#endif
      return rv;
   }

   /**
    * Converts ticks to time in seconds
    *
    * @param[in] tickInterval Time in ticks as float
    *
    * @return Time in seconds
    */
   static float __attribute__((always_inline)) convertTicksToSeconds(int tickInterval) {
      // Calculate period
      return tickInterval/Info::getClockFrequencyF();
   }


   /**
    * Get Timer count
    *
    * @return Timer count value
    */
   static __attribute__((always_inline)) uint16_t getTime() {
      return tmr->CNT;
   }
   
   /**
    *  Enables fault detection input
    *
    *  @tparam inputNum           Number of fault input to enable (0..3)
    *
    *  @param[in]  polarity       Polarity of fault input
    *  @param[in]  filterEnable   Whether to enable filtering on the fault input
    *  @param[in]  filterDelay    Delay used by the filter (1..15) - Applies to all channels
    *
    *  NOTE - the filter delay is shared by all inputs
    */
public:
   template<uint8_t inputNum>
   static void enableFault(
         Polarity polarity     = ActiveHigh,
         bool     filterEnable = false,
         uint32_t filterDelay  = (1<<FTM_FLTCTRL_FFVAL_SHIFT)-1) {

#ifdef DEBUG_BUILD
   static_assert((inputNum<Info::InfoFAULT::numSignals), "FtmBase_T: Illegal fault channel");
   static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].gpioBit != UNMAPPED_PCR), "FtmBase_T: Fault signal is not mapped to a pin - Modify Configure.usbdm");
   static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].gpioBit != INVALID_PCR),  "FtmBase_T: Non-existent signal used for fault input");
   static_assert((inputNum>=Info::InfoFAULT::numSignals)||(Info::InfoFAULT::info[inputNum].gpioBit == UNMAPPED_PCR)||(Info::InfoFAULT::info[inputNum].gpioBit == INVALID_PCR)||(Info::InfoFAULT::info[inputNum].gpioBit >= 0), "Pcr_T: Illegal signal used for fault");
#endif

      PcrTable_T<typename Info::InfoFAULT, inputNum>::setPCR();

      if (polarity) {
         // Set active high
         tmr->FLTPOL &= ~(1<<inputNum);
      }
      else {
         // Set active low
         tmr->FLTPOL |= (1<<inputNum);
      }
      if (filterEnable) {
         // Enable filter & set filter delay
         tmr->FLTCTRL = ((tmr->FLTCTRL) & ~(FTM_FLTCTRL_FFVAL_MASK)) | (1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT)) | FTM_FLTCTRL_FFVAL(filterDelay);
      }
      else {
         // Disable filter
         tmr->FLTCTRL &= ~(1<<(inputNum+FTM_FLTCTRL_FFLTR0EN_SHIFT));
      }
      // Enable fault input
      tmr->FLTCTRL |= (1<<inputNum);
      // Enable fault mode (All channels, manual)
      tmr->MODE    |= FTM_MODE_FAULTM(2);
   }

   /**
    * Enables/disable the external trigger on a channel comparison or initialisation event
    *
    * @param[in] ftmExternalTrigger Indicates the event to cause the external trigger
    * @param[in] enable             Whether to enable/disable the specified trigger
    */
   static void __attribute__((always_inline)) enableExternalTrigger(FtmExternalTrigger ftmExternalTrigger, bool enable=true) {
      if (enable) {
         tmr->EXTTRIG |= ftmExternalTrigger;
      }
      else {
         tmr->EXTTRIG &= ~ftmExternalTrigger;
      }
   }

   /**
    * Enables multiple external triggers on a channel comparison or initialisation event
    *
    * @param[in] externalTriggers Indicates the events to cause the external trigger. \n
    *                             Construct from ORed FtmExternalTrigger flags e.g. FtmExternalTrigger_ch0|FtmExternalTrigger_ch3
    * @param[in] enable           Whether to enable/disable the specified triggers
    */
   static void __attribute__((always_inline)) enableExternalTriggers(int externalTriggers, bool enable=true) {
      enableExternalTrigger((FtmExternalTrigger)externalTriggers, enable);
   }

   /**
    * Enable/disable fault interrupts
    *
    * @param[in] enable True = >enabled, False => disabled
    */
   static __attribute__((always_inline)) void enableFaultInterrupt(bool enable=true) {
      if (enable) {
         tmr->MODE |= FTM_MODE_FAULTIE_MASK;
      }
      else {
         tmr->MODE &= ~FTM_MODE_FAULTIE_MASK;
      }
   }

   /**
    *  Disables fault detection input
    *
    *  @tparam inputNum        Number of fault input to enable (0..3)
    */
   template<int inputNum>
   static __attribute__((always_inline)) void disableFault() {
      static_assert(inputNum<=4, "Illegal fault channel");

      // Enable fault on channel
      tmr->FLTCTRL &= ~(1<<inputNum);
   }

   /*
    * *****************************************************************
    *          Channel functions
    * *****************************************************************
    */
   /**
    * Set Timer event time
    *
    * @param[in] eventTime  Absolute event time i.e. value to use as timer comparison value
    * @param[in] channel    Timer channel
    */
   static __attribute__((always_inline)) void setEventTime(uint16_t eventTime, int channel) {
      tmr->CONTROLS[channel].CnV = eventTime;
   }

   /**
    * Get Timer event time
    *
    * @param[in] channel    Timer channel
    *
    * @return Absolute time of last event i.e. value from timer event register
    */
   static __attribute__((always_inline)) uint16_t getEventTime(int channel) {
      return tmr->CONTROLS[channel].CnV;
   }

   /**
    * Set Timer event time relative to current event time
    *
    * @param[in] eventTime  Event time relative to current event time (i.e. Timer channel CnV value)
    * @param[in] channel    Timer channel
    */
   static __attribute__((always_inline)) void setDeltaEventTime(uint16_t eventTime, int channel) {
      tmr->CONTROLS[channel].CnV += eventTime;
   }

   /**
    * Set Timer event time relative to current timer count value
    *
    * @param[in] eventTime  Event time relative to current time (i.e. Timer CNT value)
    * @param[in] channel    Timer channel
    */
   static __attribute__((always_inline)) void setRelativeEventTime(uint16_t eventTime, int channel) {
      tmr->CONTROLS[channel].CnV = tmr->CNT + eventTime;
   }

   /**
    * Set PWM duty cycle\n
    * Higher precision float version
    *
    * @param[in] dutyCycle  Duty-cycle as percentage (float)
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the FTM register synchronisation mechanism
    */
   static void setDutyCycle(float dutyCycle, int channel) {
      if (tmr->SC&FTM_SC_CPWMS_MASK) {
         tmr->CONTROLS[channel].CnV  = round((dutyCycle*tmr->MOD)/100.0f);
      }
      else {
         tmr->CONTROLS[channel].CnV  = round((dutyCycle*(tmr->MOD+1))/100.0f);
      }
   }

   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    * @param[in] channel    Timer channel
    *
    * @note The actual CnV register update may be delayed by the FTM register synchronisation mechanism
    */
   static void setDutyCycle(int dutyCycle, int channel) {
      if (tmr->SC&FTM_SC_CPWMS_MASK) {
         tmr->CONTROLS[channel].CnV  = (dutyCycle*tmr->MOD)/100;
      }
      else {
         tmr->CONTROLS[channel].CnV  = (dutyCycle*(tmr->MOD+1))/100;
      }
   }

   /**
    * Set PWM high time in ticks
    * Assumes value is less than period
    *
    * @param[in] highTime   PWM high time in ticks
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    * @return E_TOO_LARGE on success
    */
   static ErrorCode setHighTime(uint32_t highTime, int channel) {

      if (tmr->SC&FTM_SC_CPWMS_MASK) {
         // In CPWM the pulse width is doubled
         highTime = (highTime+1)/2;
      }
#ifdef DEBUG_BUILD
      if (highTime > tmr->MOD) {
         return setErrorCode(E_TOO_LARGE);
      }
#endif
      tmr->CONTROLS[channel].CnV  = highTime;
      return E_NO_ERROR;
   }

   /**
    * Set PWM high time in seconds
    *
    * @param[in] highTime   PWM high time in seconds
    * @param[in] channel    Timer channel
    *
    * @return E_NO_ERROR on success
    */
   static __attribute__((always_inline)) ErrorCode setHighTime(float highTime, int channel) {
      return setHighTime(convertSecondsToTicks(highTime), channel);
   }

};

/**
 * Template class to provide Timer callback
 */
template<class Info>
class FtmIrq_T : public FtmBase_T<Info> {

protected:
   /** Callback function for TOI ISR */
   static FtmCallbackFunction toiCallback;
   /** Callback function for Channel ISR */
   static FtmChannelCallbackFunction callback;
   /** Callback function for Channel Fault */
   static FtmCallbackFunction faultCallback;

public:
   /**
    * IRQ handler
    */
   static void irqHandler() {
      if ((FtmBase_T<Info>::tmr->MODE&FTM_MODE_FAULTIE_MASK) && (FtmBase_T<Info>::tmr->FMS&FTM_FMS_FAULTF_MASK)) {
         FtmBase_T<Info>::tmr->FMS &= ~FTM_FMS_FAULTF_MASK;
         faultCallback();
      }

      if ((FtmBase_T<Info>::tmr->SC&(FTM_SC_TOF_MASK|FTM_SC_TOIE_MASK)) == (FTM_SC_TOF_MASK|FTM_SC_TOIE_MASK)) {
         // Clear TOI flag
         FtmBase_T<Info>::tmr->SC &= ~FTM_SC_TOF_MASK;
         toiCallback();
      }
      uint8_t status = FtmBase_T<Info>::tmr->STATUS;
      if (status) {
         // Clear flags for channel events being handled (w0c register if read)
         FtmBase_T<Info>::tmr->STATUS = 0;
         callback(status);
      }
   }

   /**
    * Set TOI Callback function\n
    * Note that one callback is shared by all channels of the FTM
    *
    * @param[in] theCallback Callback function to execute on overflow interrupt.\n
    *                        nullptr to indicate none
    */
   static __attribute__((always_inline)) void setTimerOverflowCallback(FtmCallbackFunction theCallback) {
      if (theCallback == nullptr) {
         toiCallback = FtmIrq_T<Info>::unhandledCallback;
         return;
      }
      toiCallback = theCallback;
   }
   /**
    * Set channel Callback function\n
    * Note that one callback is shared by all channels of the FTM
    *
    * @param[in] theCallback Callback function to execute on channel interrupt.\n
    *                        nullptr to indicate none
    */
   static __attribute__((always_inline)) void setChannelCallback(FtmChannelCallbackFunction theCallback) {
      if (theCallback == nullptr) {
         callback = FtmBase_T<Info>::unhandledCallback;
         return;
      }
      callback = theCallback;
   }
   /**
    * Set fault Callback function\n
    * Note that one callback is shared by all channels of the FTM
    *
    * @param[in] theCallback Callback function to execute on fault interrupt.\n
    *                        nullptr to indicate none
    */
   static __attribute__((always_inline)) void setFaultCallback(FtmCallbackFunction theCallback) {
      if (theCallback == nullptr) {
         faultCallback = FtmBase_T<Info>::unhandledCallback;
         return;
      }
      faultCallback = theCallback;
   }
};

template<class Info> FtmCallbackFunction           FtmIrq_T<Info>::toiCallback   = FtmBase_T<Info>::unhandledCallback;
template<class Info> FtmChannelCallbackFunction    FtmIrq_T<Info>::callback      = FtmBase_T<Info>::unhandledCallback;
template<class Info> FtmCallbackFunction           FtmIrq_T<Info>::faultCallback = FtmBase_T<Info>::unhandledCallback;

/**
 * Template class representing a timer channel
 *
 * Example
 * @code
 * // Instantiate the timer channel (for FTM0 channel 6)
 * using Tmr0_ch6 = USBDM::FtmChannel<FTM0Info, 6>;
 *
 * // Enable and initialise Base FTM with initial alignment
 * Tmr0_ch6::Ftm::configure(FtmMode_LeftAlign);
 *
 * // Change timer period (in ticks) (affects ALL channels of timer)
 * Tmr0_ch6.Ftm::setPeriod(500);
 *
 * // Configure channel as PWM
 * Tmr0_ch6::configure(FtmChMode_PwmHighTruePulses);
 *
 * // Change duty cycle (in percent)
 * Tmr0_ch6.setDutyCycle(45);
 * @endcode
 *
 * @tparam channel FTM timer channel
 */
template <class Info, int channel>
class FtmChannel_T : public FtmIrq_T<Info>, protected PcrTable_T<Info, channel>, CheckSignal<Info, channel> {

protected:
   // Allow more convenient access to template super-classes
   using PcrBase = PcrBase_T<Info::info[channel].pcrAddress>;

public:
   // Allow more convenient access to template super-classes
   using Pcr = PcrTable_T<Info, channel>;
   using Ftm = FtmIrq_T<Info>;

   // Allow access to timer hardware instance
   using FtmBase_T<Info>::tmr;

   // Make these PCR functions available
   using Pcr::setDriveMode;
   using Pcr::setDriveStrength;
   using Pcr::setFilter;
   using Pcr::setPullDevice;
   using Pcr::setSlewRate;

   /**
    * Set callback for Pin IRQ
    *
    * @note There is a single callback function for all pins on the related port.
    *
    * @param[in] callback The function to call on Pin interrupt.\n
    *                     nullptr to indicate none
    */
   static __attribute__((always_inline)) void setPinCallback(PinCallbackFunction callback) {
      PcrBase::setCallback(callback);
   }

   /** Timer channel number */
   static constexpr uint32_t CHANNEL      = channel;

   /** Mask for Timer channel */
   static constexpr uint32_t CHANNEL_MASK = 1<<channel;

   /**
    * Configure channel and sets mode\n
    * Configures owning FTM with default settings from Configure.usbdmProject if not already enabled.
    *
    * @param[in] ftmChMode      Mode of operation for FTM e.g.FtmChMode_PwmHighTruePulses
    * @param[in] ftmChannelIrq  Whether to enable the interrupt function on this channel
    * @param[in] ftmChannelDma  Whether to enable the DMA function on this channel
    *
    * @note Enables FTM as well
    * @note This method has the side-effect of clearing the register update synchronisation i.e. 
    *       pending CnV register updates are discarded.
    */
   static void defaultConfigure(
         FtmChMode      ftmChMode     = FtmChMode_PwmHighTruePulses,
         FtmChannelIrq  ftmChannelIrq = FtmChannelIrq_Disable,
         FtmChannelDma  ftmChannelDma = FtmChannelDma_Disable) {
            
      if (!Ftm::isEnabled()) {
         // Enable parent FTM if needed
         Ftm::defaultConfigure();
      }
      Ftm::tmr->CONTROLS[channel].CnSC = ftmChMode|ftmChannelIrq|ftmChannelDma;
   }

   /**
    * Configure channel and sets channel mode\n
    * Doesn't affect shared settings of owning Timer
    *
    * @param[in] ftmChMode      Mode of operation for channel
    * @param[in] ftmChannelIrq  Whether to enable the interrupt function on this channel
    * @param[in] ftmChannelDma  Whether to enable the DMA function on this channel
    *
    * @note This method has the side-effect of clearing the register update synchronisation i.e.
    *       pending CnV register updates are discarded.
    */
   static __attribute__((always_inline)) void configure(
         FtmChMode      ftmChMode     = FtmChMode_PwmHighTruePulses,
         FtmChannelIrq  ftmChannelIrq = FtmChannelIrq_Disable,
         FtmChannelDma  ftmChannelDma = FtmChannelDma_Disable) {

#ifdef DEBUG_BUILD
      // Check that owning FTM has been enabled
      assert(Ftm::isEnabled());
#endif

      Ftm::tmr->CONTROLS[channel].CnSC = ftmChMode|ftmChannelIrq|ftmChannelDma;
   }

   /**
    * Enable or disable interrupt from this channel\n
    * Note: It is necessary to enableNvicInterrupts() as well
    *
    * @param[in] enable  True => enable, False => disable
    *
    * @note This method has the side-effect of clearing the register update synchronisation i.e.\n
    *       pending CnV register updates are discarded.
    */
   static __attribute__((always_inline)) void enableInterrupts(bool enable=true) {
      if (enable) {
         Ftm::tmr->CONTROLS[channel].CnSC |= FTM_CnSC_CHIE_MASK;
      }
      else {
         Ftm::tmr->CONTROLS[channel].CnSC &= ~FTM_CnSC_CHIE_MASK;
      }
   }

   /**
    * Enable or disable DMA requests from this channel\n
    *
    * @param[in] enable  True => enable, False => disable
    *
    * @note This method has the side-effect of clearing the register update synchronisation i.e.\n
    *       pending CnV register updates are discarded.
    */
   static __attribute__((always_inline)) void enableDma(bool enable=true) {
      if (enable) {
         Ftm::tmr->CONTROLS[channel].CnSC |= FTM_CnSC_DMA_MASK;
      }
      else {
         Ftm::tmr->CONTROLS[channel].CnSC &= ~FTM_CnSC_DMA_MASK;
      }
   }

   /**
    * Enable/disable interrupts in NVIC
    *
    * @param[in] enable true to enable, false to disable
    */
   static __attribute__((always_inline)) void enableNvicInterrupts(bool enable=true) {
      FtmIrq_T<Info>::enableNvicInterrupts(enable);
   }

   /**
    * Enable/disable Pin interrupts in NVIC
    *
    * @param[in] enable true => enable, false => disable
    */
   static __attribute__((always_inline)) void enablePinNvicInterrupts(bool enable=true) {
      Pcr::enableNvicInterrupts(enable);
   }

   /**
    * Set Pin Control Register Value (apart from pin multiplexor value)
    *
    * @param[in] pcrValue PCR value to set
    */
   static __attribute__((always_inline)) void setPCR(PcrValue pcrValue) {
      Pcr::setPCR((pcrValue&~PORT_PCR_MUX_MASK)|(Info::info[channel].pcrValue&PORT_PCR_MUX_MASK));
   }

   /**
    * Set Pin Control Register (PCR) value
    *
    * @param[in] pinPull          One of PinPull_None, PinPull_Up, PinPull_Down (defaults to PinPull_None)
    * @param[in] pinDriveStrength One of PinDriveStrength_Low, PinDriveStrength_High (defaults to PinDriveLow)
    * @param[in] pinDriveMode     One of PinDriveMode_PushPull, PinDriveMode_OpenDrain (defaults to PinPushPull)
    * @param[in] pinIrq           One of PinIrq_None, etc (defaults to PinIrq_None)
    * @param[in] pinFilter        One of PinFilter_None, PinFilter_Passive (defaults to PinFilter_None)
    * @param[in] pinSlewRate      One of PinSlewRate_Slow, PinSlewRate_Fast (defaults to PinSlewRate_Fast)
    * @param[in] pinMux           One of PinMux_Analogue, PinMux_Gpio etc (defaults to FTM selection value)
    */
   static __attribute__((always_inline)) void setPCR(
         PinPull           pinPull,
         PinDriveStrength  pinDriveStrength  = PinDriveStrength_Low,
         PinDriveMode      pinDriveMode      = PinDriveMode_PushPull,
         PinIrq            pinIrq            = PinIrq_None,
         PinFilter         pinFilter         = PinFilter_None,
         PinSlewRate       pinSlewRate       = PinSlewRate_Fast,
         PinMux            pinMux            = (PinMux)(Info::info[channel].pcrValue&PORT_PCR_MUX_MASK)
         ) {
      Pcr::setPCR(pinPull,pinDriveStrength,pinDriveMode,pinIrq,pinFilter,pinSlewRate,pinMux);
   }
   /**
    * Set PWM high time in ticks\n
    * Assumes value is less than period
    *
    * @param[in] highTime   PWM high time in ticks
    *
    * @return E_NO_ERROR on success
    *
    * @note The actual CnV register update will be delayed by the FTM register synchronisation mechanism
    */
   static __attribute__((always_inline)) ErrorCode setHighTimeInTicks(uint32_t highTime) {
      return Ftm::setHighTime(highTime, channel);
   }

   /**
    * Set PWM high time in seconds\n
    * Higher precision float version
    *
    * @param[in] highTime   PWM high time in seconds
    *
    * @return E_NO_ERROR on success
    *
    * @note The actual CnV register update will be delayed by the FTM register synchronisation mechanism
    */
   static __attribute__((always_inline)) ErrorCode setHighTime(float highTime) {
      return Ftm::setHighTime(highTime, channel);
   }
   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    *
    * @note The actual CnV register update will be delayed by the FTM register synchronisation mechanism
    */
   static __attribute__((always_inline)) void setDutyCycle(int dutyCycle) {
      Ftm::setDutyCycle(dutyCycle, channel);
   }

   /**
    * Set PWM duty cycle
    *
    * @param[in] dutyCycle  Duty-cycle as percentage
    *
    * @note The actual CnV register update will be delayed by the FTM register synchronisation mechanism
    */
   static __attribute__((always_inline)) void setDutyCycle(float dutyCycle) {
      Ftm::setDutyCycle(dutyCycle, channel);
   }

   /**
    * Set Timer event time
    *
    * @param[in] eventTime  Event time relative to current event time (i.e. Timer channel CnV value)
    *
    * @note The actual CnV register update will be delayed by the FTM register synchronisation mechanism
    */
   static __attribute__((always_inline)) void setDeltaEventTime(uint16_t eventTime) {
      Ftm::setDeltaEventTime(eventTime, channel);
   }

   /**
    * Set Timer event time relative to current timer count value
    *
    * @param[in] eventTime  Event time relative to current time (i.e. Timer CNT value)
    *
    * @note The actual CnV register update will be delayed by the FTM register synchronisation mechanism
    */
   static __attribute__((always_inline)) void setRelativeEventTime(uint16_t eventTime) {
      Ftm::setRelativeEventTime(eventTime, channel);
   }

   /**
    * Set Absolute Timer event time
    *
    * @param[in] eventTime  Absolute event time i.e. value to use as timer comparison value
    *
    * @note The actual CnV register update will be delayed by the FTM register synchronisation mechanism
    */
   static __attribute__((always_inline)) void setEventTime(uint16_t eventTime) {
      Ftm::setEventTime(eventTime, channel);
   }

   /**
    * Get Absolute Timer event time
    *
    * @return Absolute time of last event i.e. value from timer event register
    */
   static __attribute__((always_inline)) uint16_t getEventTime() {
      return Ftm::getEventTime(channel);
   }

   /**
    * Clear interrupt flag on channel
    */
   static __attribute__((always_inline)) void clearInterruptFlag(void) {
      Ftm::tmr->CONTROLS[channel].CnSC &= ~FTM_CnSC_CHF_MASK;
   }
};

#ifdef USBDM_FTM0_IS_DEFINED
/**
 * Template class representing a Timer channel
 *
 * Example
 * @code
 * // Instantiate the timer channel (for FTM0 channel 6)
 * using Tmr0_ch6 = USBDM::Ftm0Channel<6>;
 *
 * // Enable and initialise Base FTM with initial alignment
 * Tmr0_ch6::Ftm::configure(FtmMode_LeftAlign);
 *
 * // Change timer period (in ticks) (affects ALL channels of timer)
 * Tmr0_ch6.Ftm::setPeriod(500);
 *
 * // Configure channel as PWM
 * Tmr0_ch6::configure(FtmChMode_PwmHighTruePulses);
 *
 * // Change duty cycle (in percent)
 * Tmr0_ch6.setDutyCycle(45);
 * @endcode
 *
 * @tparam channel Timer channel
 */
template <int channel>
class Ftm0Channel : public FtmChannel_T<Ftm0Info, channel> {};

/**
 * Class representing FTM0
 */
using Ftm0 = FtmIrq_T<Ftm0Info>;
#endif

#ifdef USBDM_FTM1_IS_DEFINED
/**
 * Template class representing a FTM1 timer channel
 *
 * Refer @ref Ftm0Channel
 *
 * @tparam channel Timer channel
 */
template <int channel>
class Ftm1Channel : public FtmChannel_T<Ftm1Info, channel> {};

/**
 * Class representing FTM1
 */
using Ftm1 = FtmIrq_T<Ftm1Info>;
#endif

#ifdef USBDM_FTM2_IS_DEFINED
/**
 * Template class representing a FTM2 timer channel
 *
 * Refer @ref Ftm0Channel
 *
 * @tparam channel Timer channel
 */
template <int channel>
class Ftm2Channel : public FtmChannel_T<Ftm2Info, channel> {};

/**
 * Class representing FTM2
 */
using Ftm2 = FtmIrq_T<Ftm2Info>;
#endif

#ifdef USBDM_FTM3_IS_DEFINED
/**
 * Template class representing a FTM3 timer channel
 *
 * Refer @ref Ftm0Channel
 *
 * @tparam channel Timer channel
 */
template <int channel>
class Ftm3Channel : public FtmChannel_T<Ftm3Info, channel> {};

/**
 * Class representing FTM3
 */
using Ftm3 = FtmIrq_T<Ftm3Info>;
#endif

/**
 * Template class representing a FTM configured as a Quadrature encoder
 *
 * @tparam info      Information class for FTM
 *
 * @code
 *  QuadEncoder_T<Ftm0Info> encoder0;
 *
 *  for(;;) {
 *     printf("Position = %d\n", encoder.getPosition());
 *  }
 * @endcode
 */
template <class Info>
class QuadEncoder_T : public FtmIrq_T<Info> {

#ifdef DEBUG_BUILD
   static_assert(Info::InfoQUAD::info[0].gpioBit != UNMAPPED_PCR, "QuadEncoder_T: FTM PHA is not mapped to a pin - Modify Configure.usbdm");
   static_assert(Info::InfoQUAD::info[1].gpioBit != UNMAPPED_PCR, "QuadEncoder_T: FTM PHB is not mapped to a pin - Modify Configure.usbdm");
#endif

public:
   static constexpr volatile FTM_Type *ftm      = Info::ftm;
   static constexpr volatile uint32_t *clockReg = Info::clockReg;

   /**
    * Enable with default settings\n
    * Includes configuring all pins
    */
   static void configure() {
      Info::InfoQUAD::initPCRs();

      // Enable clock to timer
      *clockReg |= Info::clockMask;
      __DMB();

      FtmBase_T<Info>::configure(FtmMode_Quadrature);

      ftm->QDCTRL =
            FTM_QDCTRL_QUADEN_MASK|      // Enable Quadrature encoder
            FTM_QDCTRL_QUADMODE(0);      // Quadrature mode
      ftm->CONF   = FTM_CONF_BDMMODE(3);
   }
   /**
    * Enable/disables filtering of quadrature inputs
    *
    * @param[in] filterValue 0=>disable, 1..15 filter length
    */
   static void enableFilter(int filterValue=7) {
      if (filterValue>0) {
         ftm->FILTER |= FTM_FILTER_CH0FVAL(filterValue)| FTM_FILTER_CH1FVAL(filterValue);
         ftm->QDCTRL |= FTM_QDCTRL_PHAFLTREN_MASK|FTM_QDCTRL_PHBFLTREN_MASK;
      }
      else {
         ftm->QDCTRL &= ~(FTM_QDCTRL_PHAFLTREN_MASK|FTM_QDCTRL_PHBFLTREN_MASK);
      }
   }

   /**
    * Reset position to zero
    */
   static __attribute__((always_inline)) void resetPosition() {
      // Note: writing ANY value clears CNT (cannot set value)
      ftm->CNT = 0;
   }
   /**
    * Get Quadrature encoder position
    *
    * @return Signed number representing position relative to reference location
    */
   static __attribute__((always_inline)) int16_t getPosition() {
      return (int16_t)(ftm->CNT);
   }
};


#ifdef USBDM_FTM0_IS_DEFINED
/**
 * Class representing FTM0 as Quadrature encoder
 * Not all FTMs support this mode
 */
using QuadEncoder0 = QuadEncoder_T<Ftm0Info>;
#endif

#ifdef USBDM_FTM1_IS_DEFINED
/**
 * Class representing FTM1 as Quadrature encoder
 * Not all FTMs support this mode
 */
using QuadEncoder1 = QuadEncoder_T<Ftm1Info>;
#endif

#ifdef USBDM_FTM2_IS_DEFINED
/**
 * Class representing FTM2 as Quadrature encoder
 * Not all FTMs support this mode
 */
using QuadEncoder2 = QuadEncoder_T<Ftm2Info>;
#endif

#ifdef USBDM_FTM3_IS_DEFINED
/**
 * Class representing FTM3 as Quadrature encoder
 * Not all FTMs support this mode
 */
using QuadEncoder3 = QuadEncoder_T<Ftm3Info>;
#endif

#ifdef USBDM_FTM4_IS_DEFINED
/**
 * Class representing FTM4 as Quadrature encoder
 * Not all FTMs support this mode
 */
using QuadEncoder4 = QuadEncoder_T<Ftm4Info>;
#endif

/**
 * @}
 */
 
} // End namespace USBDM

#endif /* HEADER_FTM_H */

