/**
 * @file      pin_mapping.h (derived from MK20D5.usbdmHardware)
 * @version   1.2.0
 * @brief     Pin declarations for FRDM_K20D5
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stddef.h>
#include "derivative.h"

#include "pcr.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/** Class to static check signal mapping is valid */
template<class Info, int signalNum> class CheckSignal {
#ifdef DEBUG_BUILD
   static_assert((signalNum<Info::numSignals), "Non-existent signal - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != UNMAPPED_PCR), "Signal is not mapped to a pin - Modify Configure.usbdm");
   static_assert((signalNum>=Info::numSignals)||(Info::info[signalNum].gpioBit != INVALID_PCR),  "Signal doesn't exist in this device/package");
   static_assert((signalNum>=Info::numSignals)||((Info::info[signalNum].gpioBit == UNMAPPED_PCR)||(Info::info[signalNum].gpioBit == INVALID_PCR)||(Info::info[signalNum].gpioBit >= 0)), "Illegal signal");
#endif
};

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Abstraction for Crystal Oscillator
 * @{
 */
#define USBDM_OSC0_IS_DEFINED 
/**
 * Peripheral information for OSC, Crystal Oscillator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Osc0Info {
public:
   //! Hardware base pointer
   static constexpr volatile OSC_Type *osc   = (volatile OSC_Type *)OSC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = 0;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:osc0_mk

   //! Frequency of OSC Clock or Crystal
   static constexpr uint32_t oscclk_clock = 8000000UL;

   //! Frequency of 32K OSC Clock or Crystal (if applicable)
   static constexpr uint32_t osc32kclk_clock = 0UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      OSC_CR_ERCLKEN(1)  | // External Reference Enable
      OSC_CR_EREFSTEN(0) | // External Reference Stop Enable
      OSC_CR_SCP(2);       // Oscillator load capacitance

   /**
    * Get OSC clock (internal, assumed available)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static constexpr uint32_t getInternalClock() {
      return oscclk_clock;
   }

   /**
    * Get OSCERCLK clock (external, masked by OSC_CR_ERCLKEN)
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static uint32_t getOscerClock() {
      return (osc->CR&OSC_CR_ERCLKEN_MASK)?getInternalClock():0;
   }

   /**
    * Get OSC32KCLK clock
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static uint32_t getOsc32kClock() {
      return osc32kclk_clock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: XTAL0                = PTA19 (XTAL0)                  */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  19,  PORT_PCR_MUX(0)|defaultPcrValue  },
         /*   1: EXTAL0               = PTA18 (EXTAL0)                 */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  18,  PORT_PCR_MUX(0)|defaultPcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCHR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0x000CUL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCHR = PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0xCU);
   }

};

/** 
 * End group OSC_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Abstraction for Real Time Clock
 * @{
 */
#define USBDM_RTC_IS_DEFINED 
/**
 * Peripheral information for RTC, Real Time Clock.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RtcInfo {
public:
   //! Hardware base pointer
   static constexpr volatile RTC_Type *rtc   = (volatile RTC_Type *)RTC_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_RTC_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {RTC_Alarm_IRQn, RTC_Seconds_IRQn};

   // Template:rtc_war_rar_tsie

   //! Frequency of RTC External Clock or Crystal
   static constexpr uint32_t rtcclk_clock = 32768UL;

   //! Oscillator control register
   static constexpr uint32_t cr =
      RTC_CR_OSCE(1) | // Enables 32kHz oscillator [RTC_32K]
      RTC_CR_CLKO(0) | // Disables RTC 32kHz Clock Output
      RTC_CR_UM(0)   | // Update Mode
      RTC_CR_SUP(0)  | // Supervisor access
      RTC_CR_WPE(0)  | // Wakeup Pin Enable
      RTC_CR_SCP(2);   // RTC Oscillator load capacitance

   //! RTC Time Compensation Register
   static constexpr uint32_t tcr =
      RTC_TCR_CIR(0) | // Compensation Interval Register
      RTC_TCR_TCR(0);  // Time Compensation Register

   //! RTC Lock Register
   static constexpr uint32_t lr =
      RTC_LR_LRL(1) | // Lock Register Lock
      RTC_LR_SRL(1) | // Status Register Lock 
      RTC_LR_CRL(1) | // Control Register Lock
      RTC_LR_TCL(1);  // Time Compensation Lock

   //! RTC Write Access Register
   static constexpr uint32_t war =
      RTC_WAR_IERW(1) | // Interrupt Enable Register Write
      RTC_WAR_LRW(1)  | // Lock Register Write
      RTC_WAR_SRW(1)  | // Status Register Write
      RTC_WAR_CRW(1)  | // Control Register Write
      RTC_WAR_TCRW(1) | // Time Compensation Register Write
      RTC_WAR_TARW(1) | // Time Alarm Register Write
      RTC_WAR_TPRW(1) | // Time Prescaler Register Write
      RTC_WAR_TSRW(1);  // Time Seconds Register Write

   //! RTC Read Access Register
   static constexpr uint32_t rar =
      RTC_RAR_IERR(1) | // Interrupt Enable Register Read  
      RTC_RAR_LRR(1)  | // Lock Register Read              
      RTC_RAR_SRR(1)  | // Status Register Read            
      RTC_RAR_CRR(1)  | // Control Register Read           
      RTC_RAR_TCRR(1) | // Time Compensation Register Read 
      RTC_RAR_TARR(1) | // Time Alarm Register Read        
      RTC_RAR_TPRR(1) | // Time Prescaler Register Read    
      RTC_RAR_TSRR(1);  // Time Seconds Register Read

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Time for cold start (corrected for 12 leap years since 1970)
   static constexpr uint32_t coldStartTime = 
            ((((2017-1970)*365UL +
               (273) +
               (25+12-1))*24 +
              (0))*60 +
             (0))*60;
   /**
    * Get RTC clock frequency (internal, not masked by RTC_CR_CLKO)
    *
    * @return Clock frequency as uint32_t
    */
   static uint32_t getInternalClock() {
      return (rtc->CR&RTC_CR_OSCE_MASK)?rtcclk_clock:0;
   }

   /**
    * Get RTC clock frequency (external, masked by RTC_CR_CLKO)
    *
    * @return Clock frequency as uint32_t
    */
   static uint32_t getExternalClock() {
      return (rtc->CR&RTC_CR_CLKO_MASK)?0:getInternalClock();
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 3;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: XTAL32               = XTAL32 (XTAL32)                */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: EXTAL32              = EXTAL32 (EXTAL32)              */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: RTC_CLKOUT           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group RTC_Group
 * @}
 */
/**
 * @addtogroup MCG_Group MCG, Multipurpose Clock Generator
 * @brief Abstraction for Multipurpose Clock Generator
 * @{
 */
#define USBDM_MCG_IS_DEFINED 
/**
 * Peripheral information for MCG, Multipurpose Clock Generator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class McgInfo {
public:
   //! Hardware base pointer
   static constexpr volatile MCG_Type *mcg   = (volatile MCG_Type *)MCG_BasePtr;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {MCG_IRQn};

   // Template:mcg_mk

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Indicates need for special handling of CLKDIV1 register
   static constexpr int ERRATA_E2448 = 0;

   enum ClockMode {
      ClockMode_None = -1,
      ClockMode_FEI  = 0,
      ClockMode_FEE,
      ClockMode_FBI,
      ClockMode_BLPI,
      ClockMode_FBE,
      ClockMode_BLPE,
      ClockMode_PBE,
      ClockMode_PEE,
   };

   enum ModeFlags {
      Mode_LP  = (1<<0),
   };

   //! Frequency of Slow Internal Reference Clock [~32kHz]
   static constexpr uint32_t system_slow_irc_clock = 32768UL;

   //! Frequency of Fast Internal Reference Clock [~4MHz]
   static constexpr uint32_t system_fast_irc_clock = 4000000UL;

   //! PLL VDIV min value
   static constexpr uint32_t pll_vdiv_min = 24;

   //! PLL post divider
   static constexpr uint32_t pll_post_divider = 1;

   struct ClockInfo {
      //! Clock Mode
      const ClockMode clockMode:8;
      //! Mode flags
      const uint8_t modeFlags;
      //! Control Register 1
      const uint8_t c1;
      //! Control Register 2
      const uint8_t c2;
      //! Control Register 4
      const uint8_t c4;
      //! Control Register 5
      const uint8_t c5;
      //! Control Register 6
      const uint8_t c6;
      //! Status and Control Register
      const uint8_t sc;
      //! Control Register 7
      const uint8_t c7;
      //! Control Register 8
      const uint8_t c8;
   };

// Various clock configurations
   static const ClockInfo clockInfo[1];

   /**
    * Get MCGERCLK
    *
    * @return MCGERCLK as uint32_t
    */
   static uint32_t getErcClock() {
   
      switch((mcg->C7&MCG_C7_OSCSEL_MASK)) {
         default               : return 0;
         case MCG_C7_OSCSEL(0) : return Osc0Info::getInternalClock();
         case MCG_C7_OSCSEL(1) : return RtcInfo::getInternalClock();
      }
   }

   /**
    * Get Internal MCGIRCLK (ungated by MCG_C1_IRCLKEN_MASK)
    *
    * @return MCGIRCLK as uint32_t
    */
   static uint32_t getInternalIrcClock() {
         if (mcg->C2&MCG_C2_IRCS_MASK) {
   #ifdef MCG_SC_FCRDIV_MASK
            return (system_fast_irc_clock/(1<<((mcg->SC&MCG_SC_FCRDIV_MASK)>>MCG_SC_FCRDIV_SHIFT)));
   #else
            return system_fast_irc_clock;
   #endif
         }
         else {
            return system_slow_irc_clock;
         }
   }

   /**
    * Get MCGIRCLK (gated by MCG_C1_IRCLKEN_MASK)
    *
    * @return MCGIRCLK as uint32_t
    */
   static uint32_t getMcgIrClock() {
      if (mcg->C1&MCG_C1_IRCLKEN_MASK) {
         return getInternalIrcClock();
      }
      else {
         return 0;
      }
   }

};

/** 
 * End group MCG_Group
 * @}
 */
/**
 * @addtogroup SIM_Group SIM, System Integration Module
 * @brief Abstraction for System Integration Module
 * @{
 */
#define USBDM_SIM_IS_DEFINED 
/**
 * Peripheral information for SIM, System Integration Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class SimInfo {
public:
   //! Hardware base pointer
   static constexpr volatile SIM_Type *sim   = (volatile SIM_Type *)SIM_BasePtr;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:sim_mk20d5

   //! System Options Register 1
   static constexpr uint32_t sopt1 = 
      SIM_SOPT1_OSC32KSEL(2);     // 32K oscillator clock select

   /**
    * Get ERCLK32K clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getErc32kClock() {
   
      switch(sim->SOPT1&SIM_SOPT1_OSC32KSEL_MASK) {
         default                     : return 0;
         case SIM_SOPT1_OSC32KSEL(0) : return Osc0Info::getOsc32kClock();
         case SIM_SOPT1_OSC32KSEL(2) : return RtcInfo::getExternalClock();
         case SIM_SOPT1_OSC32KSEL(3) : return 1000;
      }
   }

   //! System Options Register 2
   static constexpr uint32_t sopt2 = 
      SIM_SOPT2_PTD7PAD(0) |       // PTD7 pad drive strength
      SIM_SOPT2_USBSRC(1) |        // USB clock source select
      SIM_SOPT2_PLLFLLSEL(1) |     // PLL/FLL clock select
      SIM_SOPT2_CLKOUTSEL(6) |     // CLKOUT pin clock source select
      SIM_SOPT2_RTCCLKOUTSEL(1);   // RTC clock out select

   /**
    * Get Peripheral clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getPeripheralClock() {
      
      switch(sim->SOPT2&SIM_SOPT2_PLLFLLSEL_MASK) {
         default:                     return 0;
         case SIM_SOPT2_PLLFLLSEL(0): return SystemMcgFllClock;
         case SIM_SOPT2_PLLFLLSEL(1): return SystemMcgPllClock;
      }
   }

   //! System Options Register 4
   static constexpr uint32_t sopt4 = 
      SIM_SOPT4_FTM0TRG0SRC(0) |   // FlexTimer 0 Hardware Trigger 0 Source Select
      SIM_SOPT4_FTM1CLKSEL(0)  |   // FlexTimer 1 External Clock Pin Select
      SIM_SOPT4_FTM0CLKSEL(0)  |   // FlexTimer 0 External Clock Pin Select
      SIM_SOPT4_FTM1CH0SRC(0)  |   // FTM1 channel 0 input capture source select
      SIM_SOPT4_FTM1FLT0(0)    |   // FlexTimer 1 Fault 0 Select
      SIM_SOPT4_FTM0FLT1(0)    |   // FlexTimer 0 Fault 1 Select
      SIM_SOPT4_FTM0FLT0(0);       // FlexTimer 0 Fault 0 Select

   //! System Options Register 5
   static constexpr uint32_t sopt5 = 
      SIM_SOPT5_UART0TXSRC(0) |      // UART 0 transmit data source select
      SIM_SOPT5_UART0RXSRC(0) |      // UART 0 receive data source select
      SIM_SOPT5_UART1TXSRC(0) |      // UART 1 transmit data source select
      SIM_SOPT5_UART1RXSRC(0);       // UART 1 receive data source select

   //! System Options Register 7
   static constexpr uint32_t sopt7 = 
      SIM_SOPT7_ADC0ALTTRGEN(0) |    // ADC0 alternate trigger enable
      SIM_SOPT7_ADC0PRETRGSEL(0) |   // ADC0 pretrigger select
      SIM_SOPT7_ADC0TRGSEL(0);       // ADC0 trigger select

   //! System Clock Divider Register 1
   static constexpr uint32_t clkdiv1 = 
      SIM_CLKDIV1_OUTDIV4(3)|  // Flash clock
      SIM_CLKDIV1_OUTDIV2(1)|  // Bus clock
      SIM_CLKDIV1_OUTDIV1(1);  // Core/system clock 

   //! System Clock Divider Register 2
   static constexpr uint32_t clkdiv2 = 
      2;  // USB clock divider divisor & fraction 

   /**
    * Get USB clock frequency
    *
    * @return Clock frequency as a uint32_t in Hz
    */
   static uint32_t getUsbClock() {
      return (getPeripheralClock()*
         (((sim->CLKDIV2&SIM_CLKDIV2_USBFRAC_MASK)>>SIM_CLKDIV2_USBFRAC_SHIFT)+1))/
         (((sim->CLKDIV2&SIM_CLKDIV2_USBDIV_MASK)>>SIM_CLKDIV2_USBDIV_SHIFT)+1);
   }

   /**
    * Initialise SIM registers
    */
   static void initRegs() {
      
      #ifdef SIM_SCGC4_USBOTG_MASK
      // The USB interface must be disabled for clock changes to have effect
      sim->SCGC4 &= ~SIM_SCGC4_USBOTG_MASK;
      #endif
   
      sim->SOPT1 = sopt1;
      sim->SOPT2 = sopt2;
      sim->SOPT4 = sopt4;
      sim->SOPT5 = sopt5;
      sim->SOPT7 = sopt7;
   
      sim->CLKDIV1 = clkdiv1;
      sim->CLKDIV2 = clkdiv2;
   }

   /**
    * Select the ADC0 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
    */
   enum SimAdc0Trigger {
      SimAdc0Trigger_PdbExTrig    = SIM_SOPT7_ADC0TRGSEL(0),   //!< External Trigger Source PDBx_EXTRG
      SimAdc0Trigger_Cmp0         = SIM_SOPT7_ADC0TRGSEL(1),   //!< Comparator 0
      SimAdc0Trigger_Cmp1         = SIM_SOPT7_ADC0TRGSEL(2),   //!< Comparator 1
      SimAdc0Trigger_3            = SIM_SOPT7_ADC0TRGSEL(3),   //!< Reserved
      SimAdc0Trigger_PitCh0       = SIM_SOPT7_ADC0TRGSEL(4),   //!< PIT Channel 0
      SimAdc0Trigger_PitCh1       = SIM_SOPT7_ADC0TRGSEL(5),   //!< PIT Channel 1
      SimAdc0Trigger_PitCh2       = SIM_SOPT7_ADC0TRGSEL(6),   //!< PIT Channel 2
      SimAdc0Trigger_PitCh3       = SIM_SOPT7_ADC0TRGSEL(7),   //!< PIT Channel 3
      SimAdc0Trigger_Ftm0         = SIM_SOPT7_ADC0TRGSEL(8),   //!< FTM0 Init and Ext Trigger Outputs
      SimAdc0Trigger_Ftm1         = SIM_SOPT7_ADC0TRGSEL(9),   //!< FTM1 Init and Ext Trigger Outputs
      SimAdc0Trigger_Ftm2         = SIM_SOPT7_ADC0TRGSEL(10),  //!< FTM2 Init and Ext Trigger Outputs (if present)
      SimAdc0Trigger_Ftm3         = SIM_SOPT7_ADC0TRGSEL(11),  //!< FTM3 Init and Ext Trigger Outputs (if present)
      SimAdc0Trigger_RtcAlarm     = SIM_SOPT7_ADC0TRGSEL(12),  //!< RTC Alarm
      SimAdc0Trigger_RtcSeconds   = SIM_SOPT7_ADC0TRGSEL(13),  //!< RTC Seconds
      SimAdc0Trigger_Lptrm        = SIM_SOPT7_ADC0TRGSEL(14),  //!< LPTMR
      SimAdc0Trigger_15           = SIM_SOPT7_ADC0TRGSEL(15),  //!< Reserved
   };

   /**
    * Select the ADC0 Alternative Trigger sources.
    * If PDB is selected then Pre-trigger 0/1 is determined by the PDB setup
    * otherwise Pre-trigger 0/1 is determined by this selection.
    */
   enum SimAdc0AltTrigger {
      SimAdc0AltTrigger_Pdb           = SIM_SOPT7_ADC0ALTTRGEN(0),                              //!< PDB trigger
      SimAdc0AltTrigger_PreTrigger_0  = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(0),   //!< Pre-trigger 0 = A (SC1[0])
      SimAdc0AltTrigger_PreTrigger_1  = SIM_SOPT7_ADC0ALTTRGEN(1)|SIM_SOPT7_ADC0PRETRGSEL(1),   //!< Pre-trigger 1 = B (SC1[1])
   };

   /**
    * Select the ADC0 Trigger source
    * 
    * If PDB is selected by SimAdc0Trigger then Pre-trigger 0/1 is determined by the PDB setup,
    * otherwise Pre-trigger 0/1 is determined by this parameter.
    * For example, setAdc0Triggers(SimAdc0AltTrigger_PreTrigger_1, SimAdc0Trigger_PitCh0) will set the trigger source
    * to PIT channel 0 and conversion will use SC1[1]/R[1]. 
    *
    * @param[in] simAdc0AltTrigger  Select the ADC0 Alternative Trigger sources 
    * @param[in] simAdc0Trigger     Select the ADC0 Trigger source in STOP and VLPS modes, or when ADC0 Alternative Trigger is active.
    */
   static void setAdc0Triggers(SimAdc0AltTrigger simAdc0AltTrigger, SimAdc0Trigger simAdc0Trigger=SimAdc0Trigger_PdbExTrig) {
      sim->SOPT7 = simAdc0Trigger|simAdc0AltTrigger;
   };

};

/** 
 * End group SIM_Group
 * @}
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
#define USBDM_ADC0_IS_DEFINED 
/**
 * Peripheral information for ADC, Analogue Input.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Adc0Info {
public:
   //! Hardware base pointer
   static constexpr volatile ADC_Type *adc   = (volatile ADC_Type *)ADC0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_ADC0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {ADC0_IRQn};

   // Template:adc0_diff_a

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Default value for ADCx_CFG1 register
   static constexpr uint32_t cfg1  = 
       ADC_CFG1_ADICLK(3)|
       ADC_CFG1_MODE(2)|
       ADC_CFG1_ADLSMP(0)|
       ADC_CFG1_ADIV(0)|
       ADC_CFG1_ADLPC(0);

   //! Default value for ADCx_CFG2 register
    static constexpr uint32_t cfg2  = 
       ADC_CFG2_MUXSEL_MASK | // Choose 'b' channels
       ADC_CFG2_ADLSTS(0)|
       ADC_CFG2_ADHSC(0)|
       ADC_CFG2_ADACKEN(0);

   //! Default value for ADCx_SC2 register
   static constexpr uint32_t sc2  =
       ADC_SC2_ACFE(0)|
       ADC_SC2_ACFGT(0)|
       ADC_SC2_ACREN(0)|
       ADC_SC2_REFSEL(0)|
       ADC_SC2_DMAEN(0)|
       ADC_SC2_ADTRG(0);

   //! Default value for ADCx_CV1 register
   static constexpr uint32_t cv1  = 0;

   //! Default value for ADCx_CV2 register
   static constexpr uint32_t cv2  = 0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 24;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: ADC0_SE0             = ADC0_DP0 (A10)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: ADC0_SE3             = ADC0_DP3 (A8)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: ADC0_SE4b            = PTC2 (D10)                     */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  2,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*   5: ADC0_SE5b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: ADC0_SE6b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: ADC0_SE7b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: ADC0_SE8             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   9: ADC0_SE9             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  10: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  11: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  12: ADC0_SE12            = PTB2 (D15)                     */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  2,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*  13: ADC0_SE13            = PTB3 (D14)                     */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  3,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*  14: ADC0_SE14            = PTC0 (A0)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  0,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*  15: ADC0_SE15            = PTC1 (A1)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  1,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*  16: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  17: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  18: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  19: ADC0_SE19            = ADC0_DM0 (A11)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  20: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  21: ADC0_SE21            = ADC0_DM3 (A9)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  22: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*  23: ADC0_SE23            = ADC0_SE23 (A7)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClocks(PORTB_CLOCK_MASK|PORTC_CLOCK_MASK);

      ((PORT_Type *)PORTB_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x000CUL);
      ((PORT_Type *)PORTC_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x0007UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTB_CLOCK_MASK|PORTC_CLOCK_MASK);

      ((PORT_Type *)PORTB_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0xCU);
      ((PORT_Type *)PORTC_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x7U);
   }

   class InfoDP {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC0_DP0             = ADC0_DP0 (A10)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
            /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   3: ADC0_DP3             = ADC0_DP3 (A8)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       * 
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoDM {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: ADC0_DM0             = ADC0_DM0 (A11)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
            /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
            /*   3: ADC0_DM3             = ADC0_DM3 (A9)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       * 
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

/** 
 * End group ADC_Group
 * @}
 */
/**
 * @addtogroup CMP_Group CMP, Analogue Comparator
 * @brief Abstraction for Analogue Comparator
 * @{
 */
#define USBDM_CMP0_IS_DEFINED 
/**
 * Peripheral information for CMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Cmp0Info {
public:
   //! Hardware base pointer
   static constexpr volatile CMP_Type *cmp   = (volatile CMP_Type *)CMP0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_CMP_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {CMP0_IRQn};

   // Template:cmp0

   //! CMP Control Register 0
   static constexpr uint32_t cr0 =
      CMP_CR0_FILTER_CNT(0)     | // Filter Sample Count
      CMP_CR0_HYSTCTR(0);         // Comparator hard block hysteresis control

   #ifndef CMP_CR1_TRIGM
   #define CMP_CR1_TRIGM(x) 0
   #endif

   //! CMP Control Register 1
   static constexpr uint32_t cr1 =
      CMP_CR1_SE(0)    | // Sample Enable
      CMP_CR1_WE(0)    | // Windowing Enable
      CMP_CR1_TRIGM(0) | // Trigger Mode Enable
      CMP_CR1_PMODE(0) | // Power mode Select
      CMP_CR1_INV(0)   | // Comparator Invert
      CMP_CR1_COS(0)   | // Comparator Output Select
      CMP_CR1_OPE(0);    // Comparator Output Pin Enable

   //! CMP Filter Period Register
   static constexpr uint32_t fpr =
      CMP_FPR_FILT_PER(0); // Filter Sample Period

   //! CMP Status and Control Register
   static constexpr uint32_t scr =
      CMP_SCR_DMAEN(0) | // DMA Enable Control
      CMP_SCR_IER(0) | // Comparator Interrupt Enable Rising
      CMP_SCR_IEF(0);  // Comparator Interrupt Enable Falling

   //! DAC Control Register
   static constexpr uint32_t daccr =
      CMP_DACCR_VRSEL(0); // Supply Voltage Reference Source Select

   //! MUX Control Register
   static constexpr uint32_t muxcr =
      CMP_MUXCR_PSEL(0)| // Plus Input Mux Control
      CMP_MUXCR_MSEL(0); // Minus Input Mux Control

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMP0_IN0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: CMP0_IN1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: CMP0_IN2             = PTC8 (D4)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  8,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*   3: CMP0_IN3             = PTC9 (D23)                     */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  9,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*   4: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   5: CMP0_IN5             = VREF_OUT (A6)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: CMP0_OUT             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClocks(PORTC_CLOCK_MASK);

      ((PORT_Type *)PORTC_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x0300UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTC_CLOCK_MASK);

      ((PORT_Type *)PORTC_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x300U);
   }

};

#define USBDM_CMP1_IS_DEFINED 
/**
 * Peripheral information for CMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Cmp1Info {
public:
   //! Hardware base pointer
   static constexpr volatile CMP_Type *cmp   = (volatile CMP_Type *)CMP1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_CMP_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {CMP1_IRQn};

   // Template:cmp0

   //! CMP Control Register 0
   static constexpr uint32_t cr0 =
      CMP_CR0_FILTER_CNT(0)     | // Filter Sample Count
      CMP_CR0_HYSTCTR(0);         // Comparator hard block hysteresis control

   #ifndef CMP_CR1_TRIGM
   #define CMP_CR1_TRIGM(x) 0
   #endif

   //! CMP Control Register 1
   static constexpr uint32_t cr1 =
      CMP_CR1_SE(0)    | // Sample Enable
      CMP_CR1_WE(0)    | // Windowing Enable
      CMP_CR1_TRIGM(0) | // Trigger Mode Enable
      CMP_CR1_PMODE(0) | // Power mode Select
      CMP_CR1_INV(0)   | // Comparator Invert
      CMP_CR1_COS(0)   | // Comparator Output Select
      CMP_CR1_OPE(0);    // Comparator Output Pin Enable

   //! CMP Filter Period Register
   static constexpr uint32_t fpr =
      CMP_FPR_FILT_PER(0); // Filter Sample Period

   //! CMP Status and Control Register
   static constexpr uint32_t scr =
      CMP_SCR_DMAEN(0) | // DMA Enable Control
      CMP_SCR_IER(0) | // Comparator Interrupt Enable Rising
      CMP_SCR_IEF(0);  // Comparator Interrupt Enable Falling

   //! DAC Control Register
   static constexpr uint32_t daccr =
      CMP_DACCR_VRSEL(0); // Supply Voltage Reference Source Select

   //! MUX Control Register
   static constexpr uint32_t muxcr =
      CMP_MUXCR_PSEL(0)| // Plus Input Mux Control
      CMP_MUXCR_MSEL(0); // Minus Input Mux Control

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 9;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMP1_IN0             = PTC2 (D10)                     */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  2,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*   1: CMP1_IN1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: CMP1_IN3             = ADC0_SE23 (A7)                 */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   5: CMP1_IN5             = VREF_OUT (A6)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   8: CMP1_OUT             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClocks(PORTC_CLOCK_MASK);

      ((PORT_Type *)PORTC_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x0004UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTC_CLOCK_MASK);

      ((PORT_Type *)PORTC_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x4U);
   }

};

/** 
 * End group CMP_Group
 * @}
 */
/**
 * @addtogroup CMT_Group CMT, Carrier Modulator Transmitter
 * @brief Abstraction for Carrier Modulator Transmitter
 * @{
 */
#define USBDM_CMT_IS_DEFINED 
/**
 * Peripheral information for CMT, Carrier Modulator Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class CmtInfo {
public:
   //! Hardware base pointer
   static constexpr volatile CMT_Type *cmt   = (volatile CMT_Type *)CMT_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_CMT_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {CMT_IRQn};

   // Template:cmt_0

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: CMT_IRO              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group CMT_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Abstraction for Control
 * @{
 */
#define USBDM_CONTROL_IS_DEFINED 
/**
 * Peripheral information for CONTROL, Control.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ControlInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 10;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: RESET_b              = RESET_b (RESET_b)              */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: JTAG_TCLK            = PTA0 (SWD_CLK)                 */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  0,   PORT_PCR_MUX(7)|defaultPcrValue  },
         /*   2: SWD_CLK              = PTA0 (SWD_CLK)                 */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  0,   PORT_PCR_MUX(7)|defaultPcrValue  },
         /*   3: JTAG_TDI             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: JTAG_TDO             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: TRACE_SWO            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: JTAG_TMS             = PTA3 (SWD_DIO)                 */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  3,   PORT_PCR_MUX(7)|defaultPcrValue  },
         /*   7: SWD_DIO              = PTA3 (SWD_DIO)                 */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  3,   PORT_PCR_MUX(7)|defaultPcrValue  },
         /*   8: NMI_b                = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   9: JTAG_TRST_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(7)|PORT_GPCLR_GPWE(0x0009UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x9U);
   }

};

/** 
 * End group Control_Group
 * @}
 */
/**
 * @addtogroup CRC_TODO_Group CRC, (Incomplete)
 * @brief Abstraction for (Incomplete)
 * @{
 */
#define USBDM_CRC0_IS_DEFINED 
/**
 * Peripheral information for CRC, (Incomplete).
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Crc0Info {
public:
   //! Hardware base pointer
   static constexpr volatile CRC_Type *crc   = (volatile CRC_Type *)CRC0_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_CRC_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

};

/** 
 * End group CRC_TODO_Group
 * @}
 */
/**
 * @addtogroup CONSOLE_Group Console, Console
 * @brief Abstraction for Console
 * @{
 */
/** 
 * End group CONSOLE_Group
 * @}
 */
/**
 * @addtogroup DMA_Group DMA, Direct Memory Access (DMA)
 * @brief Abstraction for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMA0_IS_DEFINED 
/**
 * Peripheral information for DMA, Direct Memory Access (DMA).
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Dma0Info {
public:
   //! Hardware base pointer
   static constexpr volatile DMA_Type *dma   = (volatile DMA_Type *)DMA0_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC7_DMA_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC7));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 4;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {DMA0_IRQn, DMA1_IRQn, DMA2_IRQn, DMA3_IRQn};

   // Template:dma0_4ch

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   // Number of DMA channels implemented
   static constexpr unsigned NumChannels = 4;

};

/** 
 * End group DMA_Group
 * @}
 */
/**
 * @addtogroup DMAMUX_Group DMAMUX, Direct Memory Access (DMA)
 * @brief Abstraction for Direct Memory Access (DMA)
 * @{
 */
#define USBDM_DMAMUX0_IS_DEFINED 
/**
 * Peripheral information for DMAMUX, Direct Memory Access (DMA).
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
/** 
 * DMA channel numbers 
 */
enum DmaSlot {
   DmaSlot_Disabled                    = 0,
   DmaSlot_UART0_Receive               = 2,
   DmaSlot_UART0_Transmit              = 3,
   DmaSlot_UART1_Receive               = 4,
   DmaSlot_UART1_Transmit              = 5,
   DmaSlot_UART2_Receive               = 6,
   DmaSlot_UART2_Transmit              = 7,
   DmaSlot_I2S0_Receive                = 14,
   DmaSlot_I2S0_Transmit               = 15,
   DmaSlot_SPI0_Receive                = 16,
   DmaSlot_SPI0_Transmit               = 17,
   DmaSlot_I2C0                        = 22,
   DmaSlot_FTM0_Ch_0                   = 24,
   DmaSlot_FTM0_Ch_1                   = 25,
   DmaSlot_FTM0_Ch_2                   = 26,
   DmaSlot_FTM0_Ch_3                   = 27,
   DmaSlot_FTM0_Ch_4                   = 28,
   DmaSlot_FTM0_Ch_5                   = 29,
   DmaSlot_FTM0_Ch_6                   = 30,
   DmaSlot_FTM0_Ch_7                   = 31,
   DmaSlot_FTM1_Ch_0                   = 32,
   DmaSlot_FTM1_Ch_1                   = 33,
   DmaSlot_ADC0                        = 40,
   DmaSlot_CMP0                        = 42,
   DmaSlot_CMP1                        = 43,
   DmaSlot_CMT                         = 47,
   DmaSlot_PDB                         = 48,
   DmaSlot_PortA                       = 49,
   DmaSlot_PortB                       = 50,
   DmaSlot_PortC                       = 51,
   DmaSlot_PortD                       = 52,
   DmaSlot_PortE                       = 53,
   DmaSlot_AlwaysEnabled0              = 54,
   DmaSlot_AlwaysEnabled1              = 55,
   DmaSlot_AlwaysEnabled2              = 56,
   DmaSlot_AlwaysEnabled3              = 57,
   DmaSlot_AlwaysEnabled4              = 48,
   DmaSlot_AlwaysEnabled5              = 59,
   DmaSlot_AlwaysEnabled6              = 60,
   DmaSlot_AlwaysEnabled7              = 61,
   DmaSlot_AlwaysEnabled8              = 62,
   DmaSlot_AlwaysEnabled9              = 63,
};

class Dmamux0Info {
public:
   //! Hardware base pointer
   static constexpr volatile DMAMUX_Type *dmamux   = (volatile DMAMUX_Type *)DMAMUX0_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_DMAMUX0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:dmamux0_4ch_trig_mk20d5

   // Number of DMA channels implemented
   static constexpr unsigned NumChannels = 4;

   static constexpr uint8_t chcfg0_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg1_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg2_source = DMAMUX_CHCFG_SOURCE(0);
   static constexpr uint8_t chcfg3_source = DMAMUX_CHCFG_SOURCE(0);
};

/** 
 * End group DMAMUX_Group
 * @}
 */
/**
 * @addtogroup EWM_Group EWM, External Watchdog Monitor
 * @brief Abstraction for External Watchdog Monitor
 * @{
 */
#define USBDM_EWM_IS_DEFINED 
/**
 * Peripheral information for EWM, External Watchdog Monitor.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class EwmInfo {
public:
   //! Hardware base pointer
   static constexpr volatile EWM_Type *ewm   = (volatile EWM_Type *)EWM_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_EWM_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:ewm_2

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: EWM_IN               = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: EWM_OUT_b            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group EWM_Group
 * @}
 */
/**
 * @addtogroup FTFL_Group FTFL, Flash Memory Module
 * @brief Abstraction for Flash Memory Module
 * @{
 */
#define USBDM_FTFL_IS_DEFINED 
/**
 * Peripheral information for FTFL, Flash Memory Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtflInfo {
public:
   //! Hardware base pointer
   static constexpr volatile FTFL_Type *ftfl   = (volatile FTFL_Type *)FTFL_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTFL_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:ftfl_32k_flexrom

   // Sector size for program flash (minimum erase element)
   static constexpr unsigned programFlashSectorSize = 1024;

   // Phrase size for program flash (minimum programming element)
   static constexpr unsigned programFlashPhraseSize = 4;

   // Sector size for data flash (minimum erase element)
   static constexpr unsigned dataFlashSectorSize = 1024;

   // Phrase size for data flash (minimum programming element)
   static constexpr unsigned dataFlashPhraseSize = 4;

   struct EepromSizes {
      const uint16_t size;    // EEPROM size
      const uint8_t  value;   // Value to select size
   };

   /** EEPROM Data Set Size Field */
   static constexpr EepromSizes eepromSizes[] = {
         // Size  Value
         {  32,   0x09, },
         {  64,   0x08, },
         {  128,  0x07, },
         {  256,  0x06, },
         {  512,  0x05, },
         {  1024, 0x04, },
         {  2048, 0x03, },
   };

   struct PartitionInformation {
      const uint32_t flashSize;     //! Remaining data flash
      const uint32_t eeepromSize;   //! Flash allocated to EEPROM backing store
      const uint8_t  value;         //! Partition value
   };

   /** Flash partition information */
   static constexpr PartitionInformation partitionInformation[] {
         // Flash   Backing   Value
         { 32*1024, 0*1024 ,  0xFF},
         { 24*1024, 8*1024 ,  0x01},
         { 16*1024, 16*1024,  0x0A},
         { 8*1024,  24*1024,  0x09},
         { 0*1024,  32*1024,  0x08},
   };

   /** Selects EEPROM size */
   enum EepromSel {
      eeprom32Bytes,
      eeprom64Bytes,
      eeprom128Bytes,
      eeprom256Bytes,
      eeprom512Bytes,
      eeprom1KBytes,
      eeprom2KBytes,
   };

   /** Selects division of FlexNVM between flash and EEPROM backing storage */
   enum PartitionSel {
      partition_flash32K_eeprom0K,
      partition_flash24K_eeprom8K,
      partition_flash16K_eeprom16K,
      partition_flash8K_eeprom24K,
      partition_flash0K_eeprom32K,
   
      // All EEPROM
      partition_flash0K_eeprom_all = partition_flash0K_eeprom32K,
   };

   /**
    * Selects division of the EEPROM
    * Not supported on this device
    */
   enum PartitionSplit {
      // Not supported
      partition_disabled=0x30,
   };

   //! FlexNVM - EEPROM size
   static constexpr EepromSel eepromSel = eeprom2KBytes;

   //! FlexNVM - Flash EEPROM partition
   static constexpr PartitionSel partitionSel = partition_flash0K_eeprom32K;

   //! FlexNVM - EEPROM partition - not available
   static constexpr PartitionSplit partitionSplit = partition_disabled;

};

/** 
 * End group FTFL_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, Shared Resources
 * @brief Abstraction for Shared Resources
 * @{
 */
#define USBDM_FTM_IS_DEFINED 
/**
 * Peripheral information for FTM, Shared Resources.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtmInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM_CLKIN0           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM_CLKIN1           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_FTM0_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm0Info {
public:
   //! Hardware base pointer
   static constexpr volatile FTM_Type *ftm   = (volatile FTM_Type *)FTM0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTM0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {FTM0_IRQn};

   // Template:ftm0_8ch

   //! Timer external input frequency 
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Period
   static constexpr uint32_t mod = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  = 
       0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialization Trigger Enable 

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   static constexpr uint32_t minimumResolution=100;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(ftm->SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
   
      float freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
   
      uint32_t freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM0_CH0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM0_CH1             = PTA4 (D21)                     */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  4,   PORT_PCR_MUX(3)|defaultPcrValue  },
         /*   2: FTM0_CH2             = PTC3 (D6/LED_RED)              */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  3,   PORT_PCR_MUX(4)|defaultPcrValue  },
         /*   3: FTM0_CH3             = PTC4 (D7)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  4,   PORT_PCR_MUX(4)|defaultPcrValue  },
         /*   4: FTM0_CH4             = PTD4 (D3/LED_GREEN)            */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  4,   PORT_PCR_MUX(4)|defaultPcrValue  },
         /*   5: FTM0_CH5             = PTD5 (A3)                      */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  5,   PORT_PCR_MUX(4)|defaultPcrValue  },
         /*   6: FTM0_CH6             = PTA1 (D5)                      */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  1,   PORT_PCR_MUX(3)|defaultPcrValue  },
         /*   7: FTM0_CH7             = PTA2 (D9/LED_BLUE)             */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  2,   PORT_PCR_MUX(3)|defaultPcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClocks(PORTA_CLOCK_MASK|PORTC_CLOCK_MASK|PORTD_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(3)|PORT_GPCLR_GPWE(0x0016UL);
      ((PORT_Type *)PORTC_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(4)|PORT_GPCLR_GPWE(0x0018UL);
      ((PORT_Type *)PORTD_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(4)|PORT_GPCLR_GPWE(0x0030UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK|PORTC_CLOCK_MASK|PORTD_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x16U);
      ((PORT_Type *)PORTC_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x18U);
      ((PORT_Type *)PORTD_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x30U);
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 4;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM0_FLT0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: FTM0_FLT1            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   2: FTM0_FLT2            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   3: FTM0_FLT3            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       * 
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

#define USBDM_FTM1_IS_DEFINED 
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm1Info {
public:
   //! Hardware base pointer
   static constexpr volatile FTM_Type *ftm   = (volatile FTM_Type *)FTM1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_FTM1_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {FTM1_IRQn};

   // Template:ftm1_2ch

   //! Timer external input frequency 
   static constexpr uint32_t ftmExternalClock =  0;

   //! Default Timer Period
   static constexpr uint32_t mod = FTM_MOD_MOD(10000);

   //! Default value for SC register
   static constexpr uint32_t sc  = 
       FTM_SC_CPWMS(0)| // Centre-Aligned PWM Select
       FTM_SC_CLKS(1)|  // Clock Mode Selection
       FTM_SC_TOIE(0)|  // Timer Overflow Interrupt Enable
       FTM_SC_PS(0);    // Prescale Factor Selection 

   //! Default value for EXTTRIG) register
   static constexpr uint32_t exttrig  = 
       0|                              // External Trigger Enable
       FTM_EXTTRIG_INITTRIGEN(0);    // Initialization Trigger Enable 

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   static constexpr uint32_t minimumResolution=100;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(ftm->SC&FTM_SC_CLKS_MASK) {
      default:
      case FTM_SC_CLKS(0): return 0;
      case FTM_SC_CLKS(1): return SystemBusClock;
      case FTM_SC_CLKS(2): return SystemMcgffClock;
      case FTM_SC_CLKS(3): return ftmExternalClock;
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
   
      float freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
   
      uint32_t freq = getInputClockFrequency();
      return freq/(1<<((ftm->SC&FTM_SC_PS_MASK)>>FTM_SC_PS_SHIFT));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: FTM1_CH0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: FTM1_CH1             = PTA13 (D24)                    */  { PORTA_CLOCK_MASK, PORTA_BasePtr,  GPIOA_BasePtr,  13,  PORT_PCR_MUX(3)|defaultPcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(3)|PORT_GPCLR_GPWE(0x2000UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTA_CLOCK_MASK);

      ((PORT_Type *)PORTA_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x2000U);
   }

   class InfoFAULT {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 1;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM1_FLT0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       * 
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

   class InfoQUAD {
   public:
      //! Number of signals available in info table
      static constexpr int numSignals  = 2;

      //! Information for each signal of peripheral
      static constexpr PcrInfo  info[] = {
   
            //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
            /*   0: FTM1_QD_PHA          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
            /*   1: FTM1_QD_PHB          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
      };

      /**
       * Initialise pins used by peripheral
       * 
       * @param pcrValue PCR value controlling pin options
       */
      static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
         (void)pcrValue;
      }

      /**
       * Resets pins used by peripheral
       */
      static void clearPCRs() {
      }

   }; 

};

/** 
 * End group FTM_Group
 * @}
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Abstraction for Digital Input/Output
 * @{
 */
#define USBDM_GPIOA_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioAInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTA_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOA_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t defaultPcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTA_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTA_IRQn};

   // Template:gpioa_0x400ff000

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

};

#define USBDM_GPIOB_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioBInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTB_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOB_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t defaultPcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTB_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTB_IRQn};

   // Template:gpioa_0x400ff000

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

};

#define USBDM_GPIOC_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioCInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTC_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOC_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t defaultPcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTC_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTC_IRQn};

   // Template:gpioa_0x400ff000

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

};

#define USBDM_GPIOD_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioDInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTD_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOD_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t defaultPcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTD_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTD_IRQn};

   // Template:gpioa_0x400ff000

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

};

#define USBDM_GPIOE_IS_DEFINED 
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioEInfo {
public:
   //! PORT Hardware base pointer
   static constexpr uint32_t pcrAddress   = PORTE_BasePtr;

   //! GPIO Hardware base pointer
   static constexpr uint32_t gpioAddress   = GPIOE_BasePtr;

   //! Value for PCR (including MUX value)
   static constexpr uint32_t defaultPcrValue  = GPIO_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_PORTE_MASK;

   //! Address of clock register for peripheral
   static constexpr uint32_t clockReg  = SIM_BasePtr+offsetof(SIM_Type,SCGC5);

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PORTE_IRQn};

   // Template:gpioa_0x400ff000

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

};

/** 
 * End group GPIO_Group
 * @}
 */
/**
 * @addtogroup I2C_Group I2C, Inter-Integrated-Circuit Interface
 * @brief Abstraction for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2C0_IS_DEFINED 
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class I2c0Info {
public:
   //! Hardware base pointer
   static constexpr volatile I2C_Type *i2c   = (volatile I2C_Type *)I2C0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = I2C_DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_I2C0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2C0_IRQn};

   // Template:i2c0_mk10d5

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 2;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2C0_SCL             = PTB0 (A5/ACC_SCL)              */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  0,   PORT_PCR_MUX(2)|defaultPcrValue  },
         /*   1: I2C0_SDA             = PTB1 (A4/ACC_SDA)              */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  1,   PORT_PCR_MUX(2)|defaultPcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClocks(PORTB_CLOCK_MASK);

      ((PORT_Type *)PORTB_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(2)|PORT_GPCLR_GPWE(0x0003UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTB_CLOCK_MASK);

      ((PORT_Type *)PORTB_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x3U);
   }

};

/** 
 * End group I2C_Group
 * @}
 */
/**
 * @addtogroup I2S_Group I2S, Inter-Integrated-Circuit Interface
 * @brief Abstraction for Inter-Integrated-Circuit Interface
 * @{
 */
#define USBDM_I2S0_IS_DEFINED 
/**
 * Peripheral information for I2S, Inter-Integrated-Circuit Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class I2s0Info {
public:
   //! Hardware base pointer
   static constexpr volatile I2S_Type *i2s   = (volatile I2S_Type *)I2S0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_I2S_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 2;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {I2S0_Tx_IRQn, I2S0_Rx_IRQn};

   // Template:i2s0_2ch

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: I2S0_MCLK            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: I2S0_RX_BCLK         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: I2S0_RX_FS           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: I2S0_TX_BCLK         = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: I2S0_TX_FS           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: I2S0_TXD0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   7: I2S0_RXD0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group I2S_Group
 * @}
 */
/**
 * @addtogroup LLWU_Group LLWU, Low-leakage Wake-up Unit
 * @brief Abstraction for Low-leakage Wake-up Unit
 * @{
 */
#define USBDM_LLWU_IS_DEFINED 
/**
 * Peripheral information for LLWU, Low-leakage Wake-up Unit.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class LlwuInfo {
public:
   //! Hardware base pointer
   static constexpr volatile LLWU_Type *llwu   = (volatile LLWU_Type *)LLWU_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {LLWU_IRQn};

   // Template:llwu_pe4_filt2_rst

   // Module wake ups
   static constexpr uint8_t me =  
      LLWU_ME_WUME0(0) |  // LPTMR
      LLWU_ME_WUME1(0) |  // CMP0
      LLWU_ME_WUME2(0) |  // CMP1
      LLWU_ME_WUME3(0) |  // CMP2/3 (if present)
      LLWU_ME_WUME4(0) |  // TSI0 (if present)
      LLWU_ME_WUME5(0) |  // RTC Alarm
      LLWU_ME_WUME6(0) |  //
      LLWU_ME_WUME7(0);   // RTC Seconds

   // LLWU Pin Enable registers
   static constexpr uint8_t pe1 = 
      LLWU_PE1_WUPE0(0)|   // LLWUP 0
      LLWU_PE1_WUPE1(0)|   // LLWUP 1
      LLWU_PE1_WUPE2(0)|   // LLWUP 2
      LLWU_PE1_WUPE3(0);   // LLWUP 3 

   static constexpr uint8_t pe2 = 
      LLWU_PE2_WUPE4(0)|   // LLWUP 4
      LLWU_PE2_WUPE5(0)|   // LLWUP 5
      LLWU_PE2_WUPE6(0)|   // LLWUP 6
      LLWU_PE2_WUPE7(0);   // LLWUP 7 

   static constexpr uint8_t pe3 = 
      LLWU_PE3_WUPE8(0)|   // LLWUP 8
      LLWU_PE3_WUPE9(0)|   // LLWUP 9
      LLWU_PE3_WUPE10(0)|  // LLWUP 10
      LLWU_PE3_WUPE11(0);  // LLWUP 11 

   static constexpr uint8_t pe4 = 
      LLWU_PE4_WUPE12(0)|  // LLWUP 12
      LLWU_PE4_WUPE13(0)|  // LLWUP 13
      LLWU_PE4_WUPE14(0)|  // LLWUP 14
      LLWU_PE4_WUPE15(0);  // LLWUP 15 

   // Pin Filter 1 register
   static constexpr uint8_t filt1 = 
      LLWU_FILT_FILTE(0) |   // Digital Filter On External Pin
      LLWU_FILT_FILTSEL(0);  // Filter Pin Select

   // Pin Filter 2 register
   static constexpr uint8_t filt2 =
      LLWU_FILT_FILTE(0) |   // Digital Filter On External Pin
      LLWU_FILT_FILTSEL(0);  // Filter Pin Select

   // LLWU Reset Enable register
   static constexpr uint8_t rst =
      LLWU_RST_LLRSTE(1) |  // Low-Leakage Mode RESET Enable
      LLWU_RST_RSTFILT(0);  // Digital Filter On RESET Pin

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: LLWU_P0              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   2: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   3: LLWU_P3              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: LLWU_P4              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: LLWU_P5              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: LLWU_P6              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: LLWU_P7              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   8: LLWU_P8              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   9: LLWU_P9              = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  10: LLWU_P10             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  11: LLWU_P11             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  12: LLWU_P12             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  13: LLWU_P13             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  14: LLWU_P14             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  15: LLWU_P15             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group LLWU_Group
 * @}
 */
/**
 * @addtogroup LPTMR_Group LPTMR, Low Power Timer
 * @brief Abstraction for Low Power Timer
 * @{
 */
#define USBDM_LPTMR0_IS_DEFINED 
/**
 * Peripheral information for LPTMR, Low Power Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Lptmr0Info {
public:
   //! Hardware base pointer
   static constexpr volatile LPTMR_Type *lptmr   = (volatile LPTMR_Type *)LPTMR0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_LPTMR_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC5));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {LPTMR0_IRQn};

   // Template:lptmr0_0

   //! Default Timer Compare value
   static constexpr uint32_t cmr = 65535;

   //! Default PSR value
   static constexpr uint32_t psr = 
      LPTMR_PSR_PRESCALE(0)|
      LPTMR_PSR_PBYP(0)|
      LPTMR_PSR_PCS(0);

   //! Default CSR value
   static constexpr uint32_t csr = 
      LPTMR_CSR_TIE(0)|
      LPTMR_CSR_TMS(0)|
      LPTMR_CSR_TFC(0)|
      LPTMR_CSR_TPP(0)|
      LPTMR_CSR_TPS(0);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as an uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
   
      switch(lptmr->PSR&LPTMR_PSR_PCS_MASK) {
      default:
      case LPTMR_PSR_PCS(0): return McgInfo::getMcgIrClock();
      case LPTMR_PSR_PCS(1): return SystemLpoClock;
      case LPTMR_PSR_PCS(2): return SimInfo::getErc32kClock();
      case LPTMR_PSR_PCS(3): return Osc0Info::getOscerClock();
      }
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a float in Hz
    */
   static float getClockFrequencyF() {
   
      float freq = getInputClockFrequency();
      if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   /**
    * Get clock frequency
    *
    * @return Frequency as a uint32_t in Hz (may underflow)
    */
   static uint32_t getClockFrequency() {
   
      uint32_t freq = getInputClockFrequency();
      if (lptmr->PSR&LPTMR_PSR_PBYP_MASK) {
         return freq;
      }
      return freq/(1<<(((lptmr->PSR&LPTMR_PSR_PRESCALE_MASK)>>LPTMR_PSR_PRESCALE_SHIFT)+1));
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 3;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: --                   = --                             */  { 0, 0, 0, INVALID_PCR,  0 },
         /*   1: LPTMR0_ALT1          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: LPTMR0_ALT2          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group LPTMR_Group
 * @}
 */
/**
 * @addtogroup PDB_Group PDB, Programmable Delay Block
 * @brief Abstraction for Programmable Delay Block
 * @{
 */
#define USBDM_PDB0_IS_DEFINED 
/**
 * Peripheral information for PDB, Programmable Delay Block.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Pdb0Info {
public:
   //! Hardware base pointer
   static constexpr volatile PDB_Type *pdb   = (volatile PDB_Type *)PDB0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_PDB_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PDB0_IRQn};

   // Template:pdb0_2ch_2trig_0dac_2po

   static constexpr uint32_t pdb_sc = 
      PDB_SC_MULT(0) |      // Multiplication Factor Select for Prescaler
      PDB_SC_PDBIE(0) |     // Interrupt Enable
      PDB_SC_TRGSEL(0) |    // Trigger Input Source Select
      PDB_SC_PRESCALER(0) | // Prescaler Divider Select
      PDB_SC_DMAEN(0) |     // DMA Enable
      PDB_SC_CONT(0) |     // Continuous Mode Enable
      PDB_SC_PDBEIE(0) |    // Sequence Error Interrupt Enable
      PDB_SC_LDMOD(0);      // Load Mode Select

   static constexpr uint32_t pdb_mod = 
      PDB_MOD_MOD(65535);  // PDB Modulus

   static constexpr uint32_t pdb_idly = 
      PDB_IDLY_IDLY(0);  // Counter Modulus

   struct PdbChannel {
      uint32_t c1;
      uint32_t dly0;
      uint32_t dly1;
   };

   // Number of PDB channels
   static constexpr size_t numChannels = 2;

   // Default values for channel registers
   static constexpr PdbChannel pdb_ch[numChannels] = {
   {                   // Channel[0] Control Register 1
      PDB_C1_BB(0) |   // Pre-Trigger Back-to-Back Operation Enable
      PDB_C1_TOS(0) |  // Pre-Trigger Output Select
      PDB_C1_EN(0),    // Pre-Trigger Enable
      PDB_DLY_DLY(0),  // Channel[0] pre-trigger delay 0
      PDB_DLY_DLY(0),  // Channel[0] pre-trigger delay 1
   },
   {                   // Channel[1] Control Register 1
      PDB_C1_BB(0) |   // Channel Pre-Trigger Back-to-Back Operation Enable
      PDB_C1_TOS(0) |  // Channel Pre-Trigger Output Select
      PDB_C1_EN(0),    // Channel Pre-Trigger Enable
      PDB_DLY_DLY(0),  // Channel[1] pre-trigger delay 0
      PDB_DLY_DLY(0),  // Channel[1] pre-trigger delay 1
   },
   };

   // Number of DACs
   static constexpr size_t numDacs = 0;

   static constexpr uint32_t pdb_poen = 
      PDB_POEN_POEN(0);   // Pulse-Out Enable

   // Number of PDB pulse outputs
   static constexpr size_t numPulseOutputs = 2;

   static constexpr uint32_t pdb_podly[numPulseOutputs] = {
      // Pulse Output[0] Delays {
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2

      // Pulse Output[1] Delays
      PDB_PODLY_DLY1(0) |  // Delay 1
      PDB_PODLY_DLY2(0),   // Delay 2
   }; 

   /**
     * Get PDB clock frequency
     *
     * @return Frequency as a uint32_t in Hz
     */
   static __attribute__((always_inline)) uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: PDB0_EXTRG           = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group PDB_Group
 * @}
 */
/**
 * @addtogroup PIT_Group PIT, Programmable Interrupt Timer
 * @brief Abstraction for Programmable Interrupt Timer
 * @{
 */
#define USBDM_PIT_IS_DEFINED 
/**
 * Peripheral information for PIT, Programmable Interrupt Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PitInfo {
public:
   //! Hardware base pointer
   static constexpr volatile PIT_Type *pit   = (volatile PIT_Type *)PIT_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_PIT_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 4;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {PIT0_IRQn, PIT1_IRQn, PIT2_IRQn, PIT3_IRQn};

   // Template:pit_4ch

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Default value for PIT->SC register
   static constexpr uint32_t pit_ldval  = 10000;

   //! PIT operation in debug mode
   static constexpr uint32_t mcr = 
      PIT_MCR_FRZ(0) |  // Freeze in debug mode
      PIT_MCR_MDIS(0);  // Disable

   /**
    * Get clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static __attribute__((always_inline)) uint32_t getClockFrequency() {
      return SystemBusClock;
   }

};

/** 
 * End group PIT_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Abstraction for Power
 * @{
 */
#define USBDM_POWER_IS_DEFINED 
/**
 * Peripheral information for POWER, Power.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PowerInfo {
public:
   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Number of signals available in info table
   static constexpr int numSignals  = 13;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: VBAT                 = VBAT (VBAT)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: VDD1                 = VDD1 (VDD1)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: VDD2                 = VDD2 (VDD2)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   3: VDD3                 = VDD3 (VDD3)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   4: VDDA                 = VDDA (VDDA)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   5: VOUT33               = VOUT33 (VOUT33)                */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   6: VREFH                = VREFH (VREFH)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   7: VREFL                = VREFL (VREFL)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   8: VREGIN               = VREGIN (VREGIN)                */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   9: VSS1                 = VSS1 (VSS1)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  10: VSS2                 = VSS2 (VSS2)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  11: VSS3                 = VSS3 (VSS3)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*  12: VSSA                 = VSSA (VSSA)                    */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group Power_Group
 * @}
 */
/**
 * @addtogroup SMC_Group SMC, System Mode Controller
 * @brief Abstraction for System Mode Controller
 * @{
 */
#define USBDM_SMC_IS_DEFINED 
/**
 * Peripheral information for SMC, System Mode Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class SmcInfo {
public:
   //! Hardware base pointer
   static constexpr volatile SMC_Type *smc   = (volatile SMC_Type *)SMC_BasePtr;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:smc_mk10d5

#ifndef SMC_PMPROT_AHSRUN
#define SMC_PMPROT_AHSRUN(x) 0
#endif

   // Power Mode Protection Register
   static constexpr uint8_t pmprot =  
      SMC_PMPROT_AHSRUN(0) |  // Allow High Speed Run mode
      SMC_PMPROT_AVLP(0) |  // Allow very low power modes
      SMC_PMPROT_ALLS(0) |  // Allow low leakage stop mode
      SMC_PMPROT_AVLLS(0);  // Allow very low leakage stop mode

#ifndef SMC_PMCTRL_LPWUI
#define SMC_PMCTRL_LPWUI(x) 0
#endif

   // Power Mode Control Register
   static constexpr uint8_t pmctrl =  
      SMC_PMCTRL_LPWUI(1);   // Low Power Wake Up on Interrupt

#ifndef SMC_STOPCTRL_PSTOPO
#define SMC_STOPCTRL_PSTOPO(x) 0
#endif

#ifndef SMC_STOPCTRL_LPOPO
#define SMC_STOPCTRL_LPOPO(x) 0
#endif

   // VLLS Control Register
   static constexpr uint8_t stopctrl =  
      SMC_STOPCTRL_PSTOPO(0) |  // Partial Stop Option (if present)
      SMC_STOPCTRL_PORPO(0) |  // POR Power Option
      SMC_STOPCTRL_LPOPO(0) |  // POR Power Option (if present)
      SMC_STOPCTRL_LLSM(0);   // LLS or VLLS Mode Control

};

/** 
 * End group SMC_Group
 * @}
 */
/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief Abstraction for Serial Peripheral Interface
 * @{
 */
#define USBDM_SPI0_IS_DEFINED 
/**
 * Peripheral information for SPI, Serial Peripheral Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Spi0Info {
public:
   //! Hardware base pointer
   static constexpr volatile SPI_Type *spi   = (volatile SPI_Type *)SPI0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_SPI0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {SPI0_IRQn};

   // Template:spi0_mk_pcsis6

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

#ifdef SPI_CTAR_LSBFE_SHIFT
   //! Default communication mode: order, clock phase and clock polarity
   static constexpr uint32_t modeValue = 
      SPI_CTAR_LSBFE(0)| // LSB or MSB first
      SPI_CTAR_MODE(0);  // Mode (CPOL+CPHA)

#endif

   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }

   //! Default speed (Hz)
   static constexpr uint32_t speed = 
      10000000;

   //! Number of signals available in info table
   static constexpr int numSignals  = 8;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: SPI0_SCK             = PTD1 (D13)                     */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  1,   PORT_PCR_MUX(2)|defaultPcrValue  },
         /*   1: SPI0_SIN             = PTD3 (D12)                     */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  3,   PORT_PCR_MUX(2)|defaultPcrValue  },
         /*   2: SPI0_SOUT            = PTD2 (D11)                     */  { PORTD_CLOCK_MASK, PORTD_BasePtr,  GPIOD_BasePtr,  2,   PORT_PCR_MUX(2)|defaultPcrValue  },
         /*   3: SPI0_PCS0            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: SPI0_PCS1            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: SPI0_PCS2            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: SPI0_PCS3            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: SPI0_PCS4            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClocks(PORTD_CLOCK_MASK);

      ((PORT_Type *)PORTD_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(2)|PORT_GPCLR_GPWE(0x000EUL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTD_CLOCK_MASK);

      ((PORT_Type *)PORTD_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0xEU);
   }

};

/** 
 * End group SPI_Group
 * @}
 */
/**
 * @addtogroup TSI_Group TSI, Low-leakage Wake-up Unit
 * @brief Abstraction for Low-leakage Wake-up Unit
 * @{
 */
#define USBDM_TSI0_IS_DEFINED 
/**
 * Peripheral information for TSI, Low-leakage Wake-up Unit.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Tsi0Info {
public:
   //! Hardware base pointer
   static constexpr volatile TSI_Type *tsi   = (volatile TSI_Type *)TSI0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC5_TSI0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC5));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {TSI0_IRQn};

   // Template:tsi0_mk

   static constexpr uint32_t tsi_gencs = \
      TSI_GENCS_STPE(0)       |  // TSI STOP Enable
      TSI_GENCS_STM(0)        |  // Scan Trigger Mode
      TSI_GENCS_ESOR(1)       |  // EOS or OOR Interrupt select
      TSI_GENCS_ERIE(0)       |  // Error Interrupt Enable
      TSI_GENCS_TSIIE(0)      |  // Touch Sensing Input Interrupt Module Enable
      TSI_GENCS_PS(3)         |  // Electrode Oscillator Prescaler
      TSI_GENCS_NSCN(8-1)     |  // Consecutive Scan number
      TSI_GENCS_LPSCNITV(9)   |  // Low-Power Mode Scan Interval
      TSI_GENCS_LPCLKS(0);       // Low-Power Mode Clock Source

   static constexpr uint32_t tsi_scanc = \
      TSI_SCANC_AMPSC(3)           |  // Active Mode Prescaler
      TSI_SCANC_AMCLKS(0)          |  // Active Mode Clock Source
      TSI_SCANC_SMOD(8)            |  // Scan Period Modulus
      TSI_SCANC_EXTCHRG((16/2)-1)  |  // External Oscillator Charge Current select
      TSI_SCANC_REFCHRG((16/2)-1);    // Reference Oscillator Charge Current select

   static constexpr uint32_t tsi_pen = \
      (6) |    // Pins enable channel as TSI inputs
      TSI_PEN_LPSP(1);    // Low Power Scan channel

   static constexpr uint32_t tsi_threshold = \
      TSI_THRESHOLD_LTHH(0) |   // Low Power Channel Low Threshold value
      TSI_THRESHOLD_HTHH(0);    // Low Power Channel High Threshold value

   /**
    * Get input clock when configured in Active mode
    * 
    * @return frequency on Hz
    */
   static uint32_t getInputClockFrequency() {
      switch(tsi->SCANC&TSI_SCANC_AMCLKS_MASK) {
         case TSI_SCANC_AMCLKS(0):  return 1000;
         case TSI_SCANC_AMCLKS(1):  return McgInfo::getMcgIrClock();
         case TSI_SCANC_AMCLKS(2):  return Osc0Info::getOscerClock();
      }
      return 0;
   }

   /**
    * Get input clock when configured in low power mode
    * 
    * @return frequency on Hz
    */
   static uint32_t getLowPowerInputClockFrequency() {
      switch(tsi->GENCS&TSI_GENCS_LPCLKS_MASK) {
         case TSI_GENCS_LPCLKS(0):  return 1000;
         case TSI_GENCS_LPCLKS(1):  return SimInfo::getErc32kClock();
      }
      return 0;
   }

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 16;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: TSI0_CH0             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: TSI0_CH1             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: TSI0_CH2             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: TSI0_CH3             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: TSI0_CH4             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   5: TSI0_CH5             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   6: TSI0_CH6             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   7: TSI0_CH7             = PTB2 (D15)                     */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  2,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*   8: TSI0_CH8             = PTB3 (D14)                     */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  3,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*   9: TSI0_CH9             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  10: TSI0_CH10            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*  11: TSI0_CH11            = PTB18 (Touch1)                 */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  18,  PORT_PCR_MUX(0)|defaultPcrValue  },
         /*  12: TSI0_CH12            = PTB19 (Touch2)                 */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  19,  PORT_PCR_MUX(0)|defaultPcrValue  },
         /*  13: TSI0_CH13            = PTC0 (A0)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  0,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*  14: TSI0_CH14            = PTC1 (A1)                      */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  1,   PORT_PCR_MUX(0)|defaultPcrValue  },
         /*  15: TSI0_CH15            = PTC2 (D10)                     */  { PORTC_CLOCK_MASK, PORTC_BasePtr,  GPIOC_BasePtr,  2,   PORT_PCR_MUX(0)|defaultPcrValue  },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClocks(PORTB_CLOCK_MASK|PORTC_CLOCK_MASK);

      ((PORT_Type *)PORTB_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x000CUL);
      ((PORT_Type *)PORTB_BasePtr)->GPCHR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0x000CUL);
      ((PORT_Type *)PORTC_BasePtr)->GPCLR = pcrValue|PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x0007UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTB_CLOCK_MASK|PORTC_CLOCK_MASK);

      ((PORT_Type *)PORTB_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0xCU);
      ((PORT_Type *)PORTB_BasePtr)->GPCHR = PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0xCU);
      ((PORT_Type *)PORTC_BasePtr)->GPCLR = PORT_PCR_MUX(0)|PORT_GPCLR_GPWE(0x7U);
   }

};

/** 
 * End group TSI_Group
 * @}
 */
/**
 * @addtogroup UART_Group UART, Universal Asynchronous Receiver/Transmitter
 * @brief Abstraction for Universal Asynchronous Receiver/Transmitter
 * @{
 */
#define USBDM_UART0_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Uart0Info {
public:
   //! Hardware base pointer
   static constexpr volatile UART_Type *uart   = (volatile UART_Type *)UART0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART0_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART0_RX_TX_IRQn};

   // Template:uart0_mk10d10_c7816_cea709

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   static constexpr bool statusNeedsWrite = false;

   static constexpr uint32_t defaultBaudRate = 115200;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemCoreClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 5;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART0_TX             = PTB17 (ConTx)                  */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  17,  PORT_PCR_MUX(3)|defaultPcrValue  },
         /*   1: UART0_RX             = PTB16 (ConRx)                  */  { PORTB_CLOCK_MASK, PORTB_BasePtr,  GPIOB_BasePtr,  16,  PORT_PCR_MUX(3)|defaultPcrValue  },
         /*   2: UART0_RTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART0_CTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   4: UART0_COL_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      enablePortClocks(PORTB_CLOCK_MASK);

      ((PORT_Type *)PORTB_BasePtr)->GPCHR = pcrValue|PORT_PCR_MUX(3)|PORT_GPCHR_GPWE(0x0003UL);
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
      enablePortClocks(PORTB_CLOCK_MASK);

      ((PORT_Type *)PORTB_BasePtr)->GPCHR = PORT_PCR_MUX(0)|PORT_GPCHR_GPWE(0x3U);
   }

};

#define USBDM_UART1_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Uart1Info {
public:
   //! Hardware base pointer
   static constexpr volatile UART_Type *uart   = (volatile UART_Type *)UART1_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART1_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART1_RX_TX_IRQn};

   // Template:uart1_mk10d5

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   static constexpr bool statusNeedsWrite = false;

   static constexpr uint32_t defaultBaudRate = 115200;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemCoreClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART1_TX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: UART1_RX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: UART1_RTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART1_CTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

#define USBDM_UART2_IS_DEFINED 
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Uart2Info {
public:
   //! Hardware base pointer
   static constexpr volatile UART_Type *uart   = (volatile UART_Type *)UART2_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_UART2_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {UART2_RX_TX_IRQn};

   // Template:uart1_mk10d5

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   static constexpr bool statusNeedsWrite = false;

   static constexpr uint32_t defaultBaudRate = 115200;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getInputClockFrequency() {
      return SystemBusClock;
   }

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: UART2_TX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   1: UART2_RX             = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   2: UART2_RTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: UART2_CTS_b          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group UART_Group
 * @}
 */
/**
 * @addtogroup USB_Group USB, USB OTG Controller
 * @brief Abstraction for USB OTG Controller
 * @{
 */
#define USBDM_USB0_IS_DEFINED 
/**
 * Peripheral information for USB, USB OTG Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Usb0Info {
public:
   //! Hardware base pointer
   static constexpr volatile USB_Type *usb   = (volatile USB_Type *)USB0_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_USBOTG_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 1;

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = {USB0_IRQn};

   // Template:usb0_otg_c

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = (0 == 1);

   //! Default IRQ level
   static constexpr uint32_t irqLevel =  0;

   //! Number of signals available in info table
   static constexpr int numSignals  = 4;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: USB0_DM              = USB0_DM (USB0_DM)              */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   1: USB0_DP              = USB0_DP (USB0_DP)              */  { 0, 0, 0, FIXED_NO_PCR, 0 },
         /*   2: USB_CLKIN            = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
         /*   3: USB_SOF_OUT          = --                             */  { 0, 0, 0, UNMAPPED_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group USB_Group
 * @}
 */
/**
 * @addtogroup USBDCD_Group USBDCD, USB Device Charger Detection
 * @brief Abstraction for USB Device Charger Detection
 * @{
 */
#define USBDM_USBDCD_IS_DEFINED 
/**
 * Peripheral information for USBDCD, USB Device Charger Detection.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class UsbdcdInfo {
public:
   //! Hardware base pointer
   static constexpr volatile USBDCD_Type *usbdcd   = (volatile USBDCD_Type *)USBDCD_BasePtr;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC6_USBDCD_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC6));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:usbdcd_v1_1

};

/** 
 * End group USBDCD_Group
 * @}
 */
/**
 * @addtogroup VREF_Group VREF, Voltage Reference
 * @brief Abstraction for Voltage Reference
 * @{
 */
#define USBDM_VREF_IS_DEFINED 
/**
 * Peripheral information for VREF, Voltage Reference.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class VrefInfo {
public:
   //! Hardware base pointer
   static constexpr volatile VREF_Type *vref   = (volatile VREF_Type *)VREF_BasePtr;

   //! Base value for PCR (excluding MUX value)
   static constexpr uint32_t defaultPcrValue  = DEFAULT_PCR;

   //! Clock mask for peripheral
   static constexpr uint32_t clockMask = SIM_SCGC4_VREF_MASK;

   //! Address of clock register for peripheral
   static constexpr volatile uint32_t *clockReg  = (volatile uint32_t *)(SIM_BasePtr+offsetof(SIM_Type,SCGC4));

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = 0;

   // Template:vref_c

   static constexpr uint8_t vref_trm = 
       VREF_TRM_CHOPEN(1) | // Chop oscillator enable
       VREF_TRM_TRIM(32);   // Trim bits 

   static constexpr uint8_t vref_sc = 
       VREF_SC_VREFEN(1) |   // Internal Voltage Reference enable
       VREF_SC_REGEN(1) |    // Regulator enable
       VREF_SC_ICOMPEN(1) |  // Second order curvature compensation enable
       VREF_SC_MODE_LV(1);   // Buffer Mode selection 

   //! Number of signals available in info table
   static constexpr int numSignals  = 1;

   //! Information for each signal of peripheral
   static constexpr PcrInfo  info[] = {

         //      Signal                 Pin                                 clockMask          pcrAddress      gpioAddress     bit  PCR value
         /*   0: VREF_OUT             = VREF_OUT (A6)                  */  { 0, 0, 0, FIXED_NO_PCR, 0 },
   };

   /**
    * Initialise pins used by peripheral
    * 
    * @param pcrValue PCR value controlling pin options
    */
   static void initPCRs(uint32_t pcrValue=defaultPcrValue) {
      (void)pcrValue;
   }

   /**
    * Resets pins used by peripheral
    */
   static void clearPCRs() {
   }

};

/** 
 * End group VREF_Group
 * @}
 */
/** 
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM


#include "adc.h"
#include "ftm.h"
#include "gpio.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
using adc_A11              = const USBDM::Adc0Channel<0>;
//using adc_A11              = const USBDM::Adc0Channel<19>;
using adc_A9               = const USBDM::Adc0Channel<3>;
//using adc_A9               = const USBDM::Adc0Channel<21>;
using adc_A10              = const USBDM::Adc0Channel<0>;
//using adc_A10              = const USBDM::Adc0Channel<0>;
using adc_A8               = const USBDM::Adc0Channel<3>;
//using adc_A8               = const USBDM::Adc0Channel<3>;
using adc_A7               = const USBDM::Adc0Channel<23>;
using adc_D15              = const USBDM::Adc0Channel<12>;
using adc_D14              = const USBDM::Adc0Channel<13>;
using adc_A0               = const USBDM::Adc0Channel<14>;
using adc_A1               = const USBDM::Adc0Channel<15>;
using adc_D10              = const USBDM::Adc0Channel<4>;
/** 
 * End group ADC_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Abstraction for PWM, Input capture and Output compare
 * @{
 */
using ftm_D5               = const USBDM::Ftm0Channel<6>;
using ftm_D9               = const USBDM::Ftm0Channel<7>;
using ftm_LED_BLUE         = const USBDM::Ftm0Channel<7>;
using ftm_D21              = const USBDM::Ftm0Channel<1>;
using ftm_D6               = const USBDM::Ftm0Channel<2>;
using ftm_LED_RED          = const USBDM::Ftm0Channel<2>;
using ftm_D7               = const USBDM::Ftm0Channel<3>;
using ftm_D3               = const USBDM::Ftm0Channel<4>;
using ftm_LED_GREEN        = const USBDM::Ftm0Channel<4>;
using ftm_A3               = const USBDM::Ftm0Channel<5>;
using ftm_D24              = const USBDM::Ftm1Channel<1>;
/** 
 * End group FTM_Group
 * @}
 */
/**
 * Used to configure pin-mapping before 1st use of peripherals
 */
extern void mapAllPins();
/** 
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM

/**
 *
 * @page PinSummary Pin Mapping
 *
 * @section PinsByPinName Pins by Pin Name
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  ADC0_DM0                 | ADC0_DM0/ADC0_SE19                          | A11                       | Photo-transistor       
 *  ADC0_DM3                 | ADC0_DM3/ADC0_SE21                          | A9                        | Temperature sensor       
 *  ADC0_DP0                 | ADC0_DP0/ADC0_SE0                           | A10                       | -       
 *  ADC0_DP3                 | ADC0_DP3/ADC0_SE3                           | A8                        | -       
 *  ADC0_SE23                | ADC0_SE23/CMP1_IN3                          | A7                        | -       
 *  EXTAL32                  | EXTAL32                                     | EXTAL32                   | Reserved(EXTAL32)       
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | SWD_CLK                   | Reserved (SWD)       
 *  PTA1                     | FTM0_CH6                                    | D5                        | -       
 *  PTA2                     | FTM0_CH7                                    | D9/LED_BLUE               | Blue LED, LCD_cs*       
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | SWD_DIO                   | Reserved (SWD)       
 *  PTA4                     | FTM0_CH1                                    | D21                       | -       
 *  PTA5                     | -                                           | D2                        | -       
 *  PTA12                    | -                                           | D8                        | LCD_Reset*       
 *  PTA13                    | FTM1_CH1                                    | D24                       | -       
 *  PTA18                    | EXTAL0                                      | EXTAL0                    | Reserved (EXTAL0)       
 *  PTA19                    | XTAL0                                       | XTAL0                     | Reserved (XTAL0)       
 *  PTB0                     | I2C0_SCL                                    | A5/ACC_SCL                | Accelerometer SCL       
 *  PTB1                     | I2C0_SDA                                    | A4/ACC_SDA                | Accelerometer SDA       
 *  PTB2                     | ADC0_SE12/TSI0_CH7                          | D15                       | -       
 *  PTB3                     | ADC0_SE13/TSI0_CH8                          | D14                       | -       
 *  PTB16                    | UART0_RX                                    | ConRx                     | USB Serial Rx       
 *  PTB17                    | UART0_TX                                    | ConTx                     | USB Serial Tx       
 *  PTB18                    | TSI0_CH11                                   | Touch1                    | Touch slider 1       
 *  PTB19                    | TSI0_CH12                                   | Touch2                    | Touch slider 2       
 *  PTC0                     | ADC0_SE14/TSI0_CH13                         | A0                        | -       
 *  PTC1                     | ADC0_SE15/TSI0_CH14                         | A1                        | -       
 *  PTC2                     | ADC0_SE4b/CMP1_IN0/TSI0_CH15                | D10                       | LCD_backlight       
 *  PTC3                     | FTM0_CH2                                    | D6/LED_RED                | Red LED       
 *  PTC4                     | FTM0_CH3                                    | D7                        | -       
 *  PTC5                     | -                                           | D18                       | -       
 *  PTC6                     | -                                           | D19/ACC_INT2              | -       
 *  PTC7                     | -                                           | D20                       | -       
 *  PTC8                     | CMP0_IN2                                    | D4                        | -       
 *  PTC9                     | CMP0_IN3                                    | D23                       | -       
 *  PTC10                    | -                                           | D25                       | -       
 *  PTC11                    | -                                           | D17/ACC_INT1              | -       
 *  PTD0                     | -                                           | D16                       | -       
 *  PTD1                     | SPI0_SCK                                    | D13                       | LCD_sck       
 *  PTD2                     | SPI0_SOUT                                   | D11                       | LCD_sin       
 *  PTD3                     | SPI0_SIN                                    | D12                       | -       
 *  PTD4                     | FTM0_CH4                                    | D3/LED_GREEN              | Green LED       
 *  PTD5                     | FTM0_CH5                                    | A3                        | -       
 *  PTD6                     | -                                           | A2                        | -       
 *  PTD7                     | -                                           | D22                       | -       
 *  PTE0                     | -                                           | D1                        | -       
 *  PTE1                     | -                                           | D0                        | -       
 *  RESET_b                  | RESET_b                                     | RESET_b                   | Reserved(Reset button)       
 *  USB0_DM                  | USB0_DM                                     | USB0_DM                   | Reserved(USB)       
 *  USB0_DP                  | USB0_DP                                     | USB0_DP                   | Reserved(USB)       
 *  VBAT                     | VBAT                                        | VBAT                      | -       
 *  VDD1                     | VDD1                                        | VDD1                      | -       
 *  VDD2                     | VDD2                                        | VDD2                      | -       
 *  VDD3                     | VDD3                                        | VDD3                      | -       
 *  VDDA                     | VDDA                                        | VDDA                      | -       
 *  VOUT33                   | VOUT33                                      | VOUT33                    | -       
 *  VREFH                    | VREFH                                       | VREFH                     | -       
 *  VREFL                    | VREFL                                       | VREFL                     | -       
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5                  | A6                        | -       
 *  VREGIN                   | VREGIN                                      | VREGIN                    | -       
 *  VSS1                     | VSS1                                        | VSS1                      | -       
 *  VSS2                     | VSS2                                        | VSS2                      | -       
 *  VSS3                     | VSS3                                        | VSS3                      | -       
 *  VSSA                     | VSSA                                        | VSSA                      | -       
 *  XTAL32                   | XTAL32                                      | XTAL32                    | Reserved(XTAL32)       
 *
 *
 * @section PinsByLocation Pins by Location
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  PTC0                     | ADC0_SE14/TSI0_CH13                         | A0                        | -       
 *  PTC1                     | ADC0_SE15/TSI0_CH14                         | A1                        | -       
 *  PTD6                     | -                                           | A2                        | -       
 *  PTD5                     | FTM0_CH5                                    | A3                        | -       
 *  PTB1                     | I2C0_SDA                                    | A4/ACC_SDA                | Accelerometer SDA       
 *  PTB0                     | I2C0_SCL                                    | A5/ACC_SCL                | Accelerometer SCL       
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5                  | A6                        | -       
 *  ADC0_SE23                | ADC0_SE23/CMP1_IN3                          | A7                        | -       
 *  ADC0_DP3                 | ADC0_DP3/ADC0_SE3                           | A8                        | -       
 *  ADC0_DM3                 | ADC0_DM3/ADC0_SE21                          | A9                        | Temperature sensor       
 *  ADC0_DP0                 | ADC0_DP0/ADC0_SE0                           | A10                       | -       
 *  ADC0_DM0                 | ADC0_DM0/ADC0_SE19                          | A11                       | Photo-transistor       
 *  PTB16                    | UART0_RX                                    | ConRx                     | USB Serial Rx       
 *  PTB17                    | UART0_TX                                    | ConTx                     | USB Serial Tx       
 *  PTE1                     | -                                           | D0                        | -       
 *  PTE0                     | -                                           | D1                        | -       
 *  PTA5                     | -                                           | D2                        | -       
 *  PTD4                     | FTM0_CH4                                    | D3/LED_GREEN              | Green LED       
 *  PTC8                     | CMP0_IN2                                    | D4                        | -       
 *  PTA1                     | FTM0_CH6                                    | D5                        | -       
 *  PTC3                     | FTM0_CH2                                    | D6/LED_RED                | Red LED       
 *  PTC4                     | FTM0_CH3                                    | D7                        | -       
 *  PTA12                    | -                                           | D8                        | LCD_Reset*       
 *  PTA2                     | FTM0_CH7                                    | D9/LED_BLUE               | Blue LED, LCD_cs*       
 *  PTC2                     | ADC0_SE4b/CMP1_IN0/TSI0_CH15                | D10                       | LCD_backlight       
 *  PTD2                     | SPI0_SOUT                                   | D11                       | LCD_sin       
 *  PTD3                     | SPI0_SIN                                    | D12                       | -       
 *  PTD1                     | SPI0_SCK                                    | D13                       | LCD_sck       
 *  PTB3                     | ADC0_SE13/TSI0_CH8                          | D14                       | -       
 *  PTB2                     | ADC0_SE12/TSI0_CH7                          | D15                       | -       
 *  PTD0                     | -                                           | D16                       | -       
 *  PTC11                    | -                                           | D17/ACC_INT1              | -       
 *  PTC5                     | -                                           | D18                       | -       
 *  PTC6                     | -                                           | D19/ACC_INT2              | -       
 *  PTC7                     | -                                           | D20                       | -       
 *  PTA4                     | FTM0_CH1                                    | D21                       | -       
 *  PTD7                     | -                                           | D22                       | -       
 *  PTC9                     | CMP0_IN3                                    | D23                       | -       
 *  PTA13                    | FTM1_CH1                                    | D24                       | -       
 *  PTC10                    | -                                           | D25                       | -       
 *  PTA18                    | EXTAL0                                      | EXTAL0                    | Reserved (EXTAL0)       
 *  EXTAL32                  | EXTAL32                                     | EXTAL32                   | Reserved(EXTAL32)       
 *  RESET_b                  | RESET_b                                     | RESET_b                   | Reserved(Reset button)       
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | SWD_CLK                   | Reserved (SWD)       
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | SWD_DIO                   | Reserved (SWD)       
 *  PTB18                    | TSI0_CH11                                   | Touch1                    | Touch slider 1       
 *  PTB19                    | TSI0_CH12                                   | Touch2                    | Touch slider 2       
 *  USB0_DM                  | USB0_DM                                     | USB0_DM                   | Reserved(USB)       
 *  USB0_DP                  | USB0_DP                                     | USB0_DP                   | Reserved(USB)       
 *  VBAT                     | VBAT                                        | VBAT                      | -       
 *  VDD1                     | VDD1                                        | VDD1                      | -       
 *  VDD2                     | VDD2                                        | VDD2                      | -       
 *  VDD3                     | VDD3                                        | VDD3                      | -       
 *  VDDA                     | VDDA                                        | VDDA                      | -       
 *  VOUT33                   | VOUT33                                      | VOUT33                    | -       
 *  VREFH                    | VREFH                                       | VREFH                     | -       
 *  VREFL                    | VREFL                                       | VREFL                     | -       
 *  VREGIN                   | VREGIN                                      | VREGIN                    | -       
 *  VSS1                     | VSS1                                        | VSS1                      | -       
 *  VSS2                     | VSS2                                        | VSS2                      | -       
 *  VSS3                     | VSS3                                        | VSS3                      | -       
 *  VSSA                     | VSSA                                        | VSSA                      | -       
 *  PTA19                    | XTAL0                                       | XTAL0                     | Reserved (XTAL0)       
 *  XTAL32                   | XTAL32                                      | XTAL32                    | Reserved(XTAL32)       
 *
 *
 * @section PinsByFunction Pins by Function
 *
 *    Pin Name               |   Functions                                 |  Location                 |  Description  
 *  ------------------------ | --------------------------------------------|---------------------------| ------------- 
 *  PTE1                     | -                                           | D0                        | -       
 *  ADC0_DM0                 | ADC0_DM0/ADC0_SE19                          | A11                       | Photo-transistor       
 *  ADC0_DM3                 | ADC0_DM3/ADC0_SE21                          | A9                        | Temperature sensor       
 *  ADC0_DP0                 | ADC0_DP0/ADC0_SE0                           | A10                       | -       
 *  ADC0_DP3                 | ADC0_DP3/ADC0_SE3                           | A8                        | -       
 *  PTC2                     | ADC0_SE4b/CMP1_IN0/TSI0_CH15                | D10                       | LCD_backlight       
 *  PTB2                     | ADC0_SE12/TSI0_CH7                          | D15                       | -       
 *  PTB3                     | ADC0_SE13/TSI0_CH8                          | D14                       | -       
 *  PTC0                     | ADC0_SE14/TSI0_CH13                         | A0                        | -       
 *  PTC1                     | ADC0_SE15/TSI0_CH14                         | A1                        | -       
 *  ADC0_SE23                | ADC0_SE23/CMP1_IN3                          | A7                        | -       
 *  PTC8                     | CMP0_IN2                                    | D4                        | -       
 *  PTC9                     | CMP0_IN3                                    | D23                       | -       
 *  PTA18                    | EXTAL0                                      | EXTAL0                    | Reserved (EXTAL0)       
 *  EXTAL32                  | EXTAL32                                     | EXTAL32                   | Reserved(EXTAL32)       
 *  PTA4                     | FTM0_CH1                                    | D21                       | -       
 *  PTC3                     | FTM0_CH2                                    | D6/LED_RED                | Red LED       
 *  PTC4                     | FTM0_CH3                                    | D7                        | -       
 *  PTD4                     | FTM0_CH4                                    | D3/LED_GREEN              | Green LED       
 *  PTD5                     | FTM0_CH5                                    | A3                        | -       
 *  PTA1                     | FTM0_CH6                                    | D5                        | -       
 *  PTA2                     | FTM0_CH7                                    | D9/LED_BLUE               | Blue LED, LCD_cs*       
 *  PTA13                    | FTM1_CH1                                    | D24                       | -       
 *  PTB0                     | I2C0_SCL                                    | A5/ACC_SCL                | Accelerometer SCL       
 *  PTB1                     | I2C0_SDA                                    | A4/ACC_SDA                | Accelerometer SDA       
 *  PTA0                     | JTAG_TCLK/SWD_CLK                           | SWD_CLK                   | Reserved (SWD)       
 *  PTA3                     | JTAG_TMS/SWD_DIO                            | SWD_DIO                   | Reserved (SWD)       
 *  RESET_b                  | RESET_b                                     | RESET_b                   | Reserved(Reset button)       
 *  PTD1                     | SPI0_SCK                                    | D13                       | LCD_sck       
 *  PTD3                     | SPI0_SIN                                    | D12                       | -       
 *  PTD2                     | SPI0_SOUT                                   | D11                       | LCD_sin       
 *  PTB18                    | TSI0_CH11                                   | Touch1                    | Touch slider 1       
 *  PTB19                    | TSI0_CH12                                   | Touch2                    | Touch slider 2       
 *  PTB16                    | UART0_RX                                    | ConRx                     | USB Serial Rx       
 *  PTB17                    | UART0_TX                                    | ConTx                     | USB Serial Tx       
 *  USB0_DM                  | USB0_DM                                     | USB0_DM                   | Reserved(USB)       
 *  USB0_DP                  | USB0_DP                                     | USB0_DP                   | Reserved(USB)       
 *  VBAT                     | VBAT                                        | VBAT                      | -       
 *  VDD1                     | VDD1                                        | VDD1                      | -       
 *  VDD2                     | VDD2                                        | VDD2                      | -       
 *  VDD3                     | VDD3                                        | VDD3                      | -       
 *  VDDA                     | VDDA                                        | VDDA                      | -       
 *  VOUT33                   | VOUT33                                      | VOUT33                    | -       
 *  VREFH                    | VREFH                                       | VREFH                     | -       
 *  VREFL                    | VREFL                                       | VREFL                     | -       
 *  VREF_OUT                 | VREF_OUT/CMP1_IN5/CMP0_IN5                  | A6                        | -       
 *  VREGIN                   | VREGIN                                      | VREGIN                    | -       
 *  VSS1                     | VSS1                                        | VSS1                      | -       
 *  VSS2                     | VSS2                                        | VSS2                      | -       
 *  VSS3                     | VSS3                                        | VSS3                      | -       
 *  VSSA                     | VSSA                                        | VSSA                      | -       
 *  PTA19                    | XTAL0                                       | XTAL0                     | Reserved (XTAL0)       
 *  XTAL32                   | XTAL32                                      | XTAL32                    | Reserved(XTAL32)       
 *
 */

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */
