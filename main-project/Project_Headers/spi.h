/**
 * @file     spi.h (180.ARM_Peripherals/Project_Headers/spi-MK.h)
 * @brief    Serial Peripheral Interface
 *
 * @version  V4.12.1.80
 * @date     13 April 2016
 */
#ifndef INCLUDE_USBDM_SPI_H_
#define INCLUDE_USBDM_SPI_H_
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include "derivative.h"
#include "hardware.h"
#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif

namespace USBDM {

/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief C++ Class allowing access to SPI interface
 * @{
 */

/**
 * Type definition for DMA interrupt call back
 * @param status Interrupt status value from SPI->SR
 */
typedef void (*SpiCallbackFunction)(uint32_t status);

enum SpiMode {
   SpiMode_0 = SPI_CTAR_CPOL(0)|SPI_CTAR_CPHA(0), // Active-high clock (idles low), Data is captured on leading edge of SCK and changes on the following edge.
   SpiMode_1 = SPI_CTAR_CPOL(0)|SPI_CTAR_CPHA(1), // Active-high clock (idles low), Data is changes on leading edge of SCK and captured on the following edge.
   SpiMode_2 = SPI_CTAR_CPOL(1)|SPI_CTAR_CPHA(0), // Active-low clock (idles high), Data is captured on leading edge of SCK and changes on the following edge.
   SpiMode_3 = SPI_CTAR_CPOL(1)|SPI_CTAR_CPHA(1), // Active-low clock (idles high), Data is changes on leading edge of SCK and captured on the following edge.
};

enum SpiOrder {
   SpiOrder_MsbFirst = SPI_CTAR_LSBFE(0),
   SpiOrder_LsbFirst = SPI_CTAR_LSBFE(1),
};

/**
 * Transmit FIFO Fill Request interrupt/DMA enable (TFFF flag)
 */
enum SpiFifoTxRequest {
   SpiFifoTxRequest_Disabled  = SPI_RSER_TFFF_DIRS(0)|SPI_RSER_TFFF_RE(0),  // Requests disabled
   SpiFifoTxRequest_Interrupt = SPI_RSER_TFFF_DIRS(0)|SPI_RSER_TFFF_RE(1),  // Generate FIFO Fill Interrupt requests (TFFF flag)
   SpiFifoTxRequest_Dma       = SPI_RSER_TFFF_DIRS(1)|SPI_RSER_TFFF_RE(1),  // Generate FIFO Fill DMA requests (TFFF flag)
};

/**
 * Receive FIFO Drain Request interrupt/DMA enable (RFDF flag)
 */
enum SpiFifoRxRequest {
   SpiFifoRxRequest_Disabled  = SPI_RSER_RFDF_DIRS(0)|SPI_RSER_RFDF_RE(0),  // Requests disabled
   SpiFifoRxRequest_Interrupt = SPI_RSER_RFDF_DIRS(0)|SPI_RSER_RFDF_RE(1),  // Generate FIFO Drain Interrupt requests (RSER flag)
   SpiFifoRxRequest_Dma       = SPI_RSER_RFDF_DIRS(1)|SPI_RSER_RFDF_RE(1),  // Generate FIFO Drain DMA requests (RSER flag)
};

/**
 * Controls Transmit FIFO Underflow interrupts (TFUF flag)
 */
enum SpiFifoUnderflowInterrupt {
   SpiFifoUnderflowInterrupt_Disabled  = SPI_RSER_TFUF_RE(0),   // Transmit FIFO Underflow interrupts disabled
   SpiFifoUnderflowInterrupt_Enabled   = SPI_RSER_TFUF_RE(1),   // Transmit FIFO Underflow interrupts enabled (TFUF flag)
};

/**
 * Controls Receive FIFO Overflow interrupts (RFOF flag)
 */
enum SpiFifoOverflowInterrupt {
   SpiFifoOverflowInterrupt_Disabled  = SPI_RSER_RFOF_RE(0),   // Receive FIFO Overflow interrupts disabled
   SpiFifoOverflowInterrupt_Enabled   = SPI_RSER_RFOF_RE(1),   // Receive FIFO Overflow interrupts enabled (RFOF flag)
};

/**
 * Controls Transmit complete interrupts (TCF Flag)
 */
enum SpiTxCompleteInterrupt {
   SpiTxCompleteInterrupt_Disabled = SPI_RSER_TCF_RE(0),    // Transmission Complete Request Enable (TCF Flag)
   SpiTxCompleteInterrupt_Enabled  = SPI_RSER_TCF_RE(1),    // Transmission Complete Request Enable (TCF Flag)
};
/**
 * Controls DSPI Finished interrupts (EOQF flag)
 */
enum SpiEndOfQueueInterrupt {
   SpiEndOfQueueInterrupt_Disable   = SPI_RSER_EOQF_RE(0),   // DSPI Finished Request Disabled
   SpiEndOfQueueInterrupt_Enable    = SPI_RSER_EOQF_RE(1),   // DSPI Finished Request Enable (EOQF flag)
};
using SpiModeValue = uint32_t;

/**
 * Calculate SPI mode value from components
 *
 * @param[in]  spiMode  SPI Mode e.g. SpiMode_0
 * @param[in]  spiOrder Bit order e.g. SpiOrder_MsbFirst
 */
static constexpr SpiModeValue spiModeValue(SpiMode spiMode=SpiMode_0, SpiOrder spiOrder=SpiOrder_MsbFirst) {
   return spiMode|spiOrder;
}

/**
 * @brief Base class for representing an SPI interface
 */
class Spi {

protected:
   /** Callback to catch unhandled interrupt */
   static void unhandledCallback(uint32_t) {
      setAndCheckErrorCode(E_NO_HANDLER);
   }

   ~Spi() {}

public:

   volatile  SPI_Type * const spi; //!< SPI hardware

protected:
   uint32_t  pushrMask;            //!< Value to combine with data

protected:
   /**
    * Constructor
    *
    * @param[in]  baseAddress    Base address of SPI
    */
   Spi(volatile SPI_Type *baseAddress) :
      spi(baseAddress), pushrMask(SPI_PUSHR_PCS_MASK) {
   }

public:
   /**
    * Calculate communication speed factors for SPI
    *
    * @param[in]  clockFrequency => Clock frequency of SPI in Hz
    * @param[in]  frequency      => Communication frequency in Hz
    *
    * @return CTAR register value including SPI_CTAR_BR, SPI_CTAR_PBR fields
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   static uint32_t calculateDividers(uint32_t clockFrequency, uint32_t frequency);

   /**
    * Calculate communication speed from SPI clock frequency and speed factors
    *
    * @param[in]  clockFrequency => Clock frequency of SPI in Hz
    * @param[in]  clockFactors   => CTAR register value providing SPI_CTAR_BR, SPI_CTAR_PBR fields
    *
    * @return Clock frequency of SPI in Hz for these factors
    */
   static uint32_t calculateSpeed(uint32_t clockFrequency, uint32_t clockFactors);

protected:
   /**
    * Calculate Delay factors
    * Used for ASC, DT and CSSCK
    *
    * @param[in]  delay          => Desired delay in seconds
    * @param[in]  clockFrequency => Clock frequency of SPI in Hz
    * @param[in]  bestPrescale   => Best prescaler value (0=>/1, 1=>/3, 2=/5, 3=>/7)
    * @param[in]  bestDivider    => Best divider value (N=>/(2**(N+1)))
    *
    * @return true
    *
    * Note: Determines bestPrescaler and bestDivider for the smallest delay that is not less than delay.
    */
   static void calculateDelay(float clockFrequency, float delay, int &bestPrescale, int &bestDivider);

   /**
    * Calculate Delay factors for CSSCK (PCS assertion to SCK Delay Scaler)
    *
    * @param[in]  delay          => Desired delay in seconds
    * @param[in]  clockFrequency => Clock frequency of SPI in Hz
    *
    * @return Masks for CTAR register
    *
    * Note: Determines value for the smallest delay that is not less than delay.
    */
   static uint32_t calculateCSSCK(float clockFrequency, float delay) {
      int bestPrescale, bestDivider;
      calculateDelay(clockFrequency, delay, bestPrescale, bestDivider);
      return SPI_CTAR_PCSSCK(bestPrescale)|SPI_CTAR_CSSCK(bestDivider);
   }

   /**
    * Calculate Delay factors for ASC (SCK to PCS negation delay)
    *
    * @param[in]  delay          => Desired delay in seconds
    * @param[in]  clockFrequency => Clock frequency of SPI in Hz
    *
    * @return Masks for CTAR register
    *
    * Note: Determines value for the smallest delay that is not less than delay.
    */
   static uint32_t calculateASC(float clockFrequency, float delay) {
      int bestPrescale, bestDivider;
      calculateDelay(clockFrequency, delay, bestPrescale, bestDivider);
      return SPI_CTAR_PASC(bestPrescale)|SPI_CTAR_ASC(bestDivider);
   }

   /**
    * Calculate Delay factors for DT (PCS negation to PCS assertion delay between transfers)
    *
    * @param[in]  delay          => Desired delay in seconds
    * @param[in]  clockFrequency => Clock frequency of SPI in Hz
    *
    * @return Masks for CTAR register
    *
    * Note: Determines value for the smallest delay that is not less than delay.
    */
   static uint32_t calculateDT(float clockFrequency, float delay) {
      int bestPrescale, bestDivider;
      calculateDelay(clockFrequency, delay, bestPrescale, bestDivider);
      return SPI_CTAR_PDT(bestPrescale)|SPI_CTAR_DT(bestDivider);
   }

   /**
    * Calculates the CTAR value for a given set of communication delays for SPI
    *
    * @param[in]  clockFrequency => Clock frequency of SPI in Hz
    * @param[in]  cssck          => PCS assertion to SCK Delay Scaler
    * @param[in]  asc            => SCK to PCS negation delay
    * @param[in]  dt             => PCS negation to PCS assertion delay between transfers
    *
    * @return Masks for CTAR register
    *
    * Note: Determines values for the smallest delay that is not less than specified delays.
    */
   static uint32_t calculateDelays(uint32_t clockFrequency, float cssck=1*USBDM::us, float asc=1*USBDM::us, float dt=1*USBDM::us) {
      uint32_t ctarValue;
      ctarValue  = calculateASC(clockFrequency, asc);
      ctarValue |= calculateDT(clockFrequency, dt);
      ctarValue |= calculateCSSCK(clockFrequency, cssck);
      return ctarValue;
   }

   /**
    * Sets Communication speed for SPI
    *
    * @param[in]  frequency      => Communication frequency in Hz
    * @param[in]  clockFrequency => Clock frequency of SPI in Hz
    * @param[in]  ctarNum        => Index of CTAR register to modify
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   void setSpeed(uint32_t clockFrequency, uint32_t frequency, int ctarNum) {
      spi->CTAR[ctarNum] = (spi->CTAR[ctarNum] & ~(SPI_CTAR_BR_MASK|SPI_CTAR_PBR_MASK)) | calculateDividers(clockFrequency, frequency);
   }

   /**
    * Sets the CTAR value for a given set of communication delays
    *
    * @param[in]  clockFrequency => Clock frequency of SPI in Hz
    * @param[in]  cssck          => PCS assertion to SCK Delay Scaler
    * @param[in]  asc            => SCK to PCS negation delay
    * @param[in]  dt             => PCS negation to PCS assertion delay between transfers
    * @param[in]  ctarNum        => Index of CTAR register to modify
    *
    * Note: Determines values for the smallest delay that is not less than specified delays.
    */
   void setDelays(uint32_t clockFrequency, float cssck, float asc, float dt, int ctarNum) {

      uint32_t ctarValue = spi->CTAR[ctarNum] &
            ~(SPI_CTAR_ASC_MASK|SPI_CTAR_PASC_MASK|SPI_CTAR_DT_MASK|SPI_CTAR_PDT_MASK|SPI_CTAR_CSSCK_MASK|SPI_CTAR_PCSSCK_MASK);
      spi->CTAR[ctarNum] = ctarValue|calculateDelays(clockFrequency, cssck, asc, dt);
   }

public:

#ifdef __CMSIS_RTOS
   /**
    * Obtain SPI mutex and set SPI configuration
    *
    * @param[in]  config       The configuration value to set for the transaction\n
    *                     A value of zero leaves the configuration unchanged
    * @param[in]  milliseconds How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK: The mutex has been obtain.
    * @return osErrorTimeoutResource: The mutex could not be obtained in the given time.
    * @return osErrorResource: The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter: The parameter mutex_id is incorrect.
    * @return osErrorISR: osMutexWait cannot be called from interrupt service routines.
    */
   virtual osStatus startTransaction(uint32_t ctarValue=0, int milliseconds=osWaitForever) = 0;

   /**
    * Release SPI mutex
    *
    * @return osOK: the mutex has been correctly released.
    * @return osErrorResource: the mutex was not obtained before.
    * @return osErrorISR: osMutexRelease cannot be called from interrupt service routines.
    */
   virtual osStatus endTransaction() = 0;
#else
   /**
    * Obtain SPI mutex(dummy) and set SPI configuration
    *
    * @param[in] config The configuration value to set for the transaction.\n
    *                   A value of zero leaves the configuration unchanged
    */
   int startTransaction(uint32_t config=0, int =0) {
      if (config != 0) {
         spi->CTAR[0] = config;
      }
      return 0;
   }
   /**
    * Release SPI mutex - dummy routine
    */
   int endTransaction() {
      return 0;
   }
#endif

   /**
    * Enable pins used by SPI
    */
   virtual void enablePins() = 0;

   /**
    * Disable (restore to usual default) pins used by SPI
    */
   virtual void disablePins() = 0;

   /**
    * Sets the CTAR value for a given set of communication delays
    *
    * @param[in]  cssck          => PCS assertion to SCK Delay Scaler
    * @param[in]  asc            => SCK to PCS negation delay
    * @param[in]  dt             => PCS negation to PCS assertion delay between transfers
    * @param[in]  ctarNum        => Index of CTAR register to modify
    *
    * Note: Determines values for the smallest delay that is not less than specified delays.
    */
   virtual void setDelays(float cssck=1*USBDM::ms, float asc=1*USBDM::ms, float dt=1*USBDM::ms, int ctarNum=0) = 0;

   /**
    * Sets the CTAR value for a given communication speed
    *
    * @param[in]  frequency => Frequency in Hz (0 => use default value)
    * @param[in]  ctarNum   => Index of CTAR register to modify
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    * Note: This will only have effect the next time a CTAR is changed
    */
   virtual void setSpeed(uint32_t frequency, int ctarNum=0) = 0;

   /**
    * Sets Communication mode for SPI
    *
    * @param[in]  mode    => SpiModeValue to set. May be calculated using spiModeValue()
    * @param[in]  ctarNum => Index of CTAR register to modify
    */
   void setMode(SpiModeValue mode, int ctarNum=0) {
      // Sets the default CTAR value with 8 bits
      spi->CTAR[ctarNum] = (spi->CTAR[ctarNum]&~(SPI_CTAR_CPHA_MASK|SPI_CTAR_CPOL_MASK|SPI_CTAR_LSBFE_MASK)) |
            (mode & (SPI_CTAR_CPHA_MASK|SPI_CTAR_CPOL_MASK|SPI_CTAR_LSBFE_MASK));
   }

   /**
    * Sets Communication mode for SPI
    *
    * @param[in]  numBits => Number of bits in each transfer
    * @param[in]  ctarNum => Index of CTAR register to modify
    */
   void setFrameSize(int numBits=8, int ctarNum=0) {
      // Sets the frame size in CTAR
      spi->CTAR[ctarNum] = (spi->CTAR[ctarNum]&~(SPI_CTAR_FMSZ_MASK)) |
            SPI_CTAR_FMSZ(numBits-1);
   }
   /**
    * Set value that is combined with data for PUSHR register
    * For example this may be used to control which CTAR is used or which SPI_PCSx signal is asserted
    *
    * @param[in]  pushrMask Value to combine with Tx data before writing to PUSHR register
    *                  For example, SPI_PUSHR_CTAS(1)|SPI_PUSHR_PCS(1<<2)
    */
   void setPushrValue(uint32_t pushrMask) {
      this->pushrMask = pushrMask;
   }
   /**
    *  Transmit and receive a series of 4 to 8-bit values
    *
    *  @param[in]  dataSize  Number of values to transfer
    *  @param[in]  txData    Transmit bytes (may be NULL for Rx only)
    *  @param[out] rxData    Receive byte buffer (may be NULL for Tx only)
    *
    *  Note: rxData may use same buffer as txData
    */
   void txRxBytes(uint32_t dataSize, const uint8_t *txData, uint8_t *rxData=0);

   /**
    *  Transmit and receive a series of 9 to 16-bit values
    *
    *  @param[in]  dataSize  Number of values to transfer
    *  @param[in]  txData    Transmit values (may be NULL for Rx only)
    *  @param[out] rxData    Receive buffer (may be NULL for Tx only)
    *
    *  Note: rxData may use same buffer as txData
    */
   void txRxWords(uint32_t dataSize, const uint16_t *txData, uint16_t *rxData=0);

   /**
    * Transmit and receive a value over SPI
    *
    * @param[in]  data - Data to send (8-16 bits) <br>
    *             May include other control bits
    *
    * @return Data received
    */
   uint32_t txRx(uint32_t data);

   /**
    *  Set SPI Configuration value\n
    *  This includes timing settings, word length and transmit order
    *
    * @param[in]  config Configuration value
    */
   void setConfig(uint32_t config) {
      spi->CTAR[0] = config;
   }

   /**
    *  Get SPI Configuration value\n
    *  This includes timing settings, word length and transmit order
    *
    * @return ctar Configuration value
    */
   uint32_t getConfig() {
      return spi->CTAR[0];
   }

   /** Set SPI.CTAR0 value
    *
    * @param[in]  ctar 32-bit CTAR value
    */
   void setCTAR0Value(uint32_t ctar) {
      spi->CTAR[0] = ctar;
   }

   /** Set SPI.CTAR1 value
    *
    * @param[in]  ctar 32-bit CTAR value
    */
   void setCTAR1Value(uint32_t ctar) {
      spi->CTAR[1] = ctar;
   }

   /** Get SPI.CTAR0 value
    *
    * @return ctar 32-bit CTAR value
    */
   uint32_t getCTAR0Value() {
      return spi->CTAR[0];
   }

   /** Get SPI.CTAR1 value
    *
    * @return ctar 32-bit CTAR value
    */
   uint32_t getCTAR1Value() {
      return spi->CTAR[1];
   }

   /**
    * Set polarity of hardware PCS signals
    *
    * @param[in]  signal    Signal number
    * @param[in]  polarity  Polarity of PCSn, ActiveHigh or ActiveLow
    */
   void setPcsPolarity(int signal, Polarity polarity=ActiveHigh) {
      if (polarity==ActiveHigh) {
         spi->MCR &= ~SPI_MCR_PCSIS(1<<signal);
      }
      else {
         spi->MCR |= SPI_MCR_PCSIS(1<<signal);
      }
   }

   /**
    * Starts and stops the SPI transfers.
    *
    * @param[in] enable true to enable
    */
   void enableTransfer(bool enable=true) {
      if (enable) {
         spi->MCR &= ~SPI_MCR_HALT_MASK;
      }
      else {
         spi->MCR |= SPI_MCR_HALT_MASK;
      }
   }
   /**
    *
    * @param[in] spiFifoTxRequest   Transmit FIFO Fill Request interrupt/DMA enable (TFFF flag)
    * @param[in] spiFifoRxRequest   Receive FIFO Drain Request interrupt/DMA enable (RFDF flag)
    */
   void configureFifoRequests(
         SpiFifoTxRequest spiFifoTxRequest,
         SpiFifoRxRequest spiFifoRxRequest) {

      spi->RSER = (spi->RSER&~(SPI_RSER_TFFF_DIRS(1)|SPI_RSER_TFFF_RE(1)|SPI_RSER_RFDF_DIRS(1)|SPI_RSER_RFDF_RE(1)))|spiFifoTxRequest|spiFifoRxRequest;
   }
   /**
    *
    * @param[in] spiTxCompleteInterrupt      Controls Transmit complete interrupts (TCF Flag)
    * @param[in] spiEndOfQueueInterrupt      Controls DSPI Finished interrupts (EOQF flag)
    * @param[in] spiFifoUnderflowInterrupt   Controls Transmit FIFO Underflow interrupts (TFUF flag)
    * @param[in] spiFifoOverflowInterrupt    Controls Transmit FIFO Overflow interrupts (TFUF flag)
    */
   void configureInterrupts(
         SpiTxCompleteInterrupt     spiTxCompleteInterrupt     = SpiTxCompleteInterrupt_Disabled,
         SpiEndOfQueueInterrupt     spiEndOfQueueInterrupt     = SpiEndOfQueueInterrupt_Disable,
         SpiFifoUnderflowInterrupt  spiFifoUnderflowInterrupt  = SpiFifoUnderflowInterrupt_Disabled,
         SpiFifoOverflowInterrupt   spiFifoOverflowInterrupt   = SpiFifoOverflowInterrupt_Disabled
         ) {

      spi->RSER = (spi->RSER&~(SPI_RSER_TFUF_RE(1)|SPI_RSER_RFOF_RE(1)|SPI_RSER_TCF_RE(1)|SPI_RSER_EOQF_RE(1)))|
            spiFifoUnderflowInterrupt|spiFifoOverflowInterrupt|spiTxCompleteInterrupt|spiEndOfQueueInterrupt;
   }
};

/**
 * @brief Template class representing a SPI interface
 *
 * @tparam  Info           Class describing Spi hardware
 */
template<class Info>
class Spi_T : public Spi {

#ifdef __CMSIS_RTOS
protected:
   /** Mutex to protect access - static so per SPI */
   static CMSIS::Mutex mutex;

public:
   /**
    * Obtain SPI mutex
    *
    * @param[in]  config       The configuration value to set for the transaction\n
    *                     A value of zero leaves the configuration unchanged
    * @param[in]  milliseconds How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK: The mutex has been obtain.
    * @return osErrorTimeoutResource: The mutex could not be obtained in the given time.
    * @return osErrorResource: The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter: The parameter mutex_id is incorrect.
    * @return osErrorISR: osMutexWait cannot be called from interrupt service routines.
    */
   virtual osStatus startTransaction(uint32_t config=0, int milliseconds=osWaitForever) override {
      // Obtain mutex
      osStatus status = mutex.wait(milliseconds);
      if ((status == osOK) && (config != 0)) {
         // Change configuration for this transaction
         spi->CTAR[0] = config;
      }
      return status;
   }

   /**
    * Release SPI mutex
    *
    * @return osOK: the mutex has been correctly released.
    * @return osErrorResource: the mutex was not obtained before.
    * @return osErrorISR: osMutexRelease cannot be called from interrupt service routines.
    */
   virtual osStatus endTransaction() override {
      // Release mutex
      return mutex.release();
   }
#endif

public:
   static constexpr volatile SPI_Type *SPI = Info::spi;

   // SPI SCK (clock) Pin
   using sckGpio  = GpioTable_T<Info, 0, USBDM::ActiveHigh>;

   // SPI SIN (data in = usually MISO) Pin
   using sinGpio  = GpioTable_T<Info, 1, USBDM::ActiveHigh>;

   // SPI SOUT (data out = usually MOSI) Pin
   using soutGpio = GpioTable_T<Info, 2, USBDM::ActiveHigh>;

   virtual ~Spi_T() {}

   virtual void enablePins() override {
      // Configure SPI pins
      Spi0Info::initPCRs(pcrValue(PinPull_Up, PinDriveStrength_High));
   }

   virtual void disablePins() override {
      // Configure SPI pins to mux=0
      Info::clearPCRs();
   }

   /**
    * Sets Communication speed for SPI
    *
    * @param[in]  frequency      => Frequency in Hz (0 => use default value)
    * @param[in]  ctarNum        => Index of CTAR register to modify
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   virtual void setSpeed(uint32_t frequency, int ctarNum=0) override {
      Spi::setSpeed(Info::getClockFrequency(), frequency, ctarNum);
   }

   /**
    * Sets the CTAR value for a given set of communication delays
    *
    * @param[in]  cssck          => PCS assertion to SCK Delay Scaler
    * @param[in]  asc            => SCK to PCS negation delay
    * @param[in]  dt             => PCS negation to PCS assertion delay between transfers
    * @param[in]  ctarNum        => Index of CTAR register to modify
    *
    * Note: Determines values for the smallest delay that is not less than specified delays.
    */
   void setDelays(float cssck=10*USBDM::us, float asc=10*USBDM::us, float dt=10*USBDM::us, int ctarNum=0) override {
      Spi::setDelays(Info::getClockFrequency(), cssck, asc, dt, ctarNum);
   }

   /**
    * Constructor
    */
   Spi_T() : Spi(reinterpret_cast<volatile SPI_Type*>(Info::spi)) {

#ifdef DEBUG_BUILD
      // Check pin assignments
      static_assert(Info::info[0].gpioBit != UNMAPPED_PCR, "SPIx_SCK has not been assigned to a pin");
      static_assert(Info::info[1].gpioBit != UNMAPPED_PCR, "SPIx_SIN has not been assigned to a pin");
      static_assert(Info::info[2].gpioBit != UNMAPPED_PCR, "SPIx_SOUT has not been assigned to a pin");
#endif

      // Enable SPI module clock
      *Info::clockReg |= Info::clockMask;
      __DMB();

      spi->MCR =
            SPI_MCR_HALT(1)|        // Halt transfers
            SPI_MCR_CLR_RXF(1)|     // Clear Rx FIFO
            SPI_MCR_CLR_TXF(1)|     // Clear Tx FIFO
            SPI_MCR_ROOE(1)|        // Receive FIFO Overflow Overwrite
            SPI_MCR_MSTR(1)|        // Master mode
            SPI_MCR_DCONF(0)|       // Must be zero
            SPI_MCR_SMPL_PT(0)|     // 0 system clocks between SCK edge and SIN sample
            SPI_MCR_PCSIS(1);       // Assume PCS active-low

      setCTAR0Value(0);         // Clear
      setCTAR1Value(0);         // Clear
      setFrameSize(8);          // Default 8-bit transfers
      setSpeed(Info::speed);    // Use default speed
      setMode(Info::modeValue); // Use default mode
      setDelays();              // Defaults

      // Configure SPI pins
      enablePins();
   }
   /**
    * Gets and clears status flags.
    *
    * @return status valkue (SPI->SR)
    */
   static uint32_t __attribute__((always_inline)) getStatus() {
      // Capture interrupt status
      uint32_t status = Info::spi->SR;
      // Clear captured flags
      Info::spi->SR = status;
      // Return status
      return status;
   }

};

/**
 * Template class to provide callback
 */
template<class Info>
class SpiIrq_T : public Spi_T<Info> {

protected:
   /** Callback function for ISR */
   static SpiCallbackFunction callback;

public:
   /**
    * IRQ handler
    */
   static void irqHandler() {
      callback(Spi_T<Info>::getStatus());
   }

   /**
    * Set Callback function\n
    *
    * @param[in] theCallback Callback function to execute on interrupt.\n
    *                        nullptr to indicate none
    */
   static __attribute__((always_inline)) void setCallback(SpiCallbackFunction theCallback) {
      if (theCallback == nullptr) {
         callback = Spi::unhandledCallback;
         return;
      }
      callback = theCallback;
   }
};

template<class Info> SpiCallbackFunction SpiIrq_T<Info>::callback = Spi::unhandledCallback;

#ifdef __CMSIS_RTOS
/** Mutex to protect access - static so per SPI */
template<class Info>
CMSIS::Mutex Spi_T<Info>::mutex;
#endif

#if defined(USBDM_SPI0_IS_DEFINED)
/**
 * @brief Template class representing a SPI0 interface
 *
 * <b>Example</b>
 * @code
 * USBDM::Spi *spi = new USBDM::Spi0();
 *
 * uint8_t txData[] = {1,2,3};
 * uint8_t rxData[10];
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 *
 */
using Spi0 = SpiIrq_T<Spi0Info>;
#endif

#if defined(USBDM_SPI1_IS_DEFINED)
/**
 * @brief Template class representing a SPI1 interface
 *
 * <b>Example</b>
 * @code
 * USBDM::Spi *spi = new USBDM::Spi1();
 *
 * uint8_t txData[] = {1,2,3};
 * uint8_t rxData[10];
 * spi->txRxBytes(sizeof(txData), txData, rxData);
 * @endcode
 *
 */
using  Spi1 = SpiIrq_T<Spi1Info>;
#endif
/**
 * @}
 */

} // End namespace USBDM

#endif /* INCLUDE_USBDM_SPI_H_ */
